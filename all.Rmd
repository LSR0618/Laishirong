```{r}
setwd("D:\\360安全浏览器下载\\课题\\6月份\\Grower")
read.csv("ASD_meta.csv",row.names = 1,header = TRUE)->ASD
read.csv("Healthy_meta.csv",row.names = 1,header = TRUE)->Healthy
rbind(ASD,Healthy)->meta
meta[,c(3,4)]->meta
meta<-meta[-which(meta$BMI>100),]
#meta<-meta%>%as.matrix()
meta<-as.data.frame(meta)
#meta$Sex[which(meta$Sex=='Male')]<-0
#meta$Sex[which(meta$Sex=='Female')]<-1
#meta[,1]<-as.factor(meta[,1])
#meta[,2]<-as.factor(meta[,2])
meta[,1]<-as.numeric(meta[,1])
meta[,2]<-as.numeric(meta[,2])
meta1<-meta
#meta1$Sex<-as.factor(meta1$Sex)
colnames(meta1)[1:2]<-c('age','BMI')
####
age<-meta$Age%>%as.numeric()
BMI<-meta$BMI%>%as.numeric()

age_normalized <- (age - min(age)) / (max(age) - min(age))
BMI_normalized <- (BMI - min(BMI)) / (max(BMI) - min(BMI))
meta1$age<-age_normalized
meta1$BMI<-BMI_normalized
####
gower_dist <- daisy(meta1,
                    metric = "gower",
                    type = list(logratio = 2))
summary(gower_dist)
sil_width <- c(NA)

for(i in 2:10){
  print(i)
  pam_fit <- pam(gower_dist,
                 diss = TRUE,
                 k = i)
  
  sil_width[i] <- pam_fit$silinfo$avg.width
  
}

plot(1:10, sil_width,
     xlab = "Number of clusters",
     ylab = "Silhouette Width")
lines(1:10, sil_width)

for(i in 2){
  print(i)
  pam_fit <- pam(gower_dist,
                 diss = TRUE,
                 k = i)
  
  sil_width[i] <- pam_fit$silinfo$avg.width
  
}




tsne_obj <- Rtsne(gower_dist, is_distance = TRUE)

tsne_data <- tsne_obj$Y %>%
  data.frame() %>%
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(pam_fit$clustering))

ggplot(aes(x = X, y = Y), data = tsne_data) +
  geom_point(aes(color = cluster))


rbind(ASD,Healthy)->meta
#meta[,c(3,4)]->meta
meta<-meta[-which(meta$BMI>100),]
table(meta$Sex[which(tsne_data$cluster==1)])
table(meta$Sex[which(tsne_data$cluster==2)])


table(meta$Disease[which(tsne_data$cluster==1)])
#table(meta$Disease[which(tsne_data$cluster==2)])
meta[which(tsne_data$cluster==1),]->meta_cluster1
meta_cluster1[which(meta_cluster1$Country=="United States of America"),]->America_meta
```

```{r}
setwd("D:\\360安全浏览器下载\\课题\\6月份\\根据菌群距离选择健康样本")
read.csv("genus(origin).csv",row.names = 1,header = TRUE)->genus
genus<-genus[-which(rownames(genus)=="Unknown"),]
genus[,match(rownames(America_meta),colnames(genus))]->genus

library(compositions)
clr(genus)->genus
t(genus)->genus
as.data.frame(genus)->genus
match(rownames(genus),rownames(America_meta))
cbind(genus,America_meta$Disease)->genus
colnames(genus)[ncol(genus)]<-"type"
library(ROSE)
as.factor(genus$type)->genus$type
as.data.frame(genus)->genus
write.csv(genus,"genus.csv")
read.csv("genus.csv",row.names = 1,header = TRUE)->genus

####Male
genus[match(rownames(America_meta)[which(America_meta$Sex=="Male")],rownames(genus)),]->Male_genus
genus[match(rownames(America_meta)[which(America_meta$Sex=="Female")],rownames(genus)),]->Female_genus

table(Male_genus$type)
balance.under <- ovun.sample(type~.,data = Male_genus,
                             #p=0.3,
                             N=416,
                             seed = 1,method = "under")$data

table(balance.under$type)


library(data.table)
dtA <- as.data.table(Male_genus)
dtB <- as.data.table(balance.under)

# 计算哪些行是匹配的
matching_indices <- dtA[, .SD, .SDcols = names(dtA)][
  dtB, on = names(dtB), nomatch = 0L, which = TRUE]
Male_genus[matching_indices,]->Male_genus1
Male_genus[-match(rownames(Male_genus1),rownames(Male_genus)),]->Male_genus_H
Male_genus[which(Male_genus$type=="ASD"),]->Male_genus_D
rbind(Male_genus_D,Male_genus_H)->Male_genus_dissimilar


table(Female_genus$type)
balance.under <- ovun.sample(type~.,data = Female_genus,
                             #p=0.3,
                             N=564,
                             seed = 1,method = "under")$data


table(balance.under$type)


library(data.table)
dtA <- as.data.table(Female_genus)
dtB <- as.data.table(balance.under)

# 计算哪些行是匹配的
matching_indices <- dtA[, .SD, .SDcols = names(dtA)][
  dtB, on = names(dtB), nomatch = 0L, which = TRUE]
Female_genus[matching_indices,]->Female_genus1
Female_genus[-match(rownames(Female_genus1),rownames(Female_genus)),]->Female_genus_H
Female_genus[which(Female_genus$type=="ASD"),]->Female_genus_D
rbind(Female_genus_D,Female_genus_H)->Female_genus_dissimilar
table(Female_genus_dissimilar$type)

rbind(Male_genus_dissimilar,Female_genus_dissimilar)->genus1
```

```{r}
b<-list()
genus2<-genus1[,-ncol(genus1)]
for (i in 1:ncol(genus2)) {
  a<-as.data.frame(table(genus2[,i]))
  a[1,2]->b[[i]]
  i=i+1
}
as.matrix(b)->b
which(b>nrow(genus2)*0.9)->c
genus2[,-c]->genus2
America_meta[match(rownames(genus2),rownames(America_meta)),]->meta
```

```{r}
#####层次聚类
library(ComplexHeatmap)
library(openxlsx)
library(dplyr)
library(pals)
library(RColorBrewer)
coul1 <- colorRampPalette(c('white','blue'))(100)
coul2 <- colorRampPalette(c('white','red'))(100)
#加载RColorBrewer这个R包
library(RColorBrewer)
#生成三张图片，按三行一列排布
par(mfrow=c(3,1))
#PiYG中一共有11中颜色，画11根柱子来展示
barplot(1:11,col=brewer.pal(11, "PiYG"))
#通过colorRampPalette生成渐变色，PiYG中本身就有11中个颜色
#后面括号中的数字是要生成渐变色的个数，也为11，所以效果跟上图一样
barplot(1:11,col=colorRampPalette(brewer.pal(11, "PiYG"))(11))
#通过colorRampPalette生成25个渐变色
barplot(1:25,col=colorRampPalette(brewer.pal(11, "PiYG"))(25))
coul <- colorRampPalette(brewer.pal(11, "PiYG"))(25)



meta[,c(2,ncol(meta)),drop=F]->meta1
ann_colors = list(
   Sex=c("Male"="purple","Female"="pink"),
   Group=c("ASD" = "#EB7369","Healthy" = "#5784C4")
)
p1<-pheatmap::pheatmap(t(genus2),
                   show_rownames = F,
                   color = col1,
                   annotation_col = meta1,
                   #cellwidth = 2, 
                   #cellheight = 2,
                   show_colnames = F,
                   cluster_rows = F,
                   #cluster_cols = F,
                   annotation_colors=ann_colors)

genus2[match(rownames(meta)[which(meta$Sex=="Male")],rownames(genus2)),]->Male_genus
genus2[match(rownames(meta)[which(meta$Sex=="Female")],rownames(genus2)),]->Female_genus
meta[match(rownames(Male_genus),rownames(meta)),ncol(meta),drop=F]->Male_group
colnames(Male_group)<-"Group"

col1 <- c(colorRampPalette(c("#009723", "white"))(abs(round(min(Male_genus),0))*100),
         colorRampPalette('white')(1),
         colorRampPalette(c("white", "#A70038"))(round(max(Male_genus),0)*100))

col2 <- c(colorRampPalette(c("#009723", "white"))(abs(round(min(Female_genus),0))*100),
         colorRampPalette('white')(1),
         colorRampPalette(c("white", "#A70038"))(round(max(Female_genus),0)*100))
colnames(meta)[ncol(meta)]<-"Group"
ann_colors = list(
   Group=c("ASD" = "#EB7369","Healthy" = "#5784C4")
)

#as.data.frame(low_meta)->low_meta
p2<-pheatmap::pheatmap(t(Male_genus),
                   show_rownames = F,
                   color = col1,
                   annotation_col = Male_group,
                   #cellwidth = 2, 
                   #cellheight = 2,
                   show_colnames = F,
                   cluster_rows = F,
                   #cluster_cols = F,
                   annotation_colors=ann_colors)







meta[match(rownames(Female_genus),rownames(meta)),ncol(meta),drop=F]->Female_group
colnames(Female_group)<-"Group"
ann_colors = list(
   Group=c("ASD" = "#EB7369","Healthy" = "#5784C4")
)

#as.data.frame(low_meta)->low_meta
p3<-pheatmap::pheatmap(t(Female_genus),
                   show_rownames = F,
                   color = col2,
                   annotation_col = Female_group,
                   #cellwidth = 2, 
                   #cellheight = 2,
                   show_colnames = F,
                   cluster_rows = F,
                   #cluster_cols = F,
                   annotation_colors=ann_colors)

```

```{r}
library(ggplot2)
read.csv("meta.csv",row.names = 1,header = T)->meta
hist(meta$Age)
meta[which(meta$Sex=="Male"),]->Male_meta
meta[which(meta$Sex=="Female"),]->Female_meta
# 年龄
p1<-ggplot(Male_meta, aes(x = Age, fill = Group)) +     # 指定年龄为x轴，并以组别填充颜色
geom_density(alpha = 0.5) +                # 设置密度图的透明度
scale_fill_manual(values = c("#EB7369", "#5784C4")) + # 手动为每个组设置颜色
labs(title = "男性组的年龄密度曲线图", x = "年龄", y = "密度")+   # 添加图表的标题和轴标题
ggtitle('A')
p1

p2<-ggplot(Female_meta, aes(x = Age, fill = Group)) +     # 指定年龄为x轴，并以组别填充颜色
geom_density(alpha = 0.5) +                # 设置密度图的透明度
scale_fill_manual(values = c("#EB7369", "#5784C4")) + # 手动为每个组设置颜色
labs(title = "女性组的年龄密度曲线图", x = "年龄", y = "密度") +  # 添加图表的标题和轴标题
ggtitle('B')
p2

# BMI
p3<-ggplot(Male_meta, aes(x = BMI, fill = Group)) +     # 指定年龄为x轴，并以组别填充颜色
geom_density(alpha = 0.5) +                # 设置密度图的透明度
scale_fill_manual(values = c("#EB7369", "#5784C4")) + # 手动为每个组设置颜色
labs(title = "男性组的年龄密度曲线图", x = "BMI", y = "密度")+   # 添加图表的标题和轴标题
ggtitle('C')
p3

p4<-ggplot(Female_meta, aes(x = BMI, fill = Group)) +     # 指定年龄为x轴，并以组别填充颜色
geom_density(alpha = 0.5) +                # 设置密度图的透明度
scale_fill_manual(values = c("#EB7369", "#5784C4")) + # 手动为每个组设置颜色
labs(title = "女性组的年龄密度曲线图", x = "BMI", y = "密度") +  # 添加图表的标题和轴标题
ggtitle('D')
p4


```
```{r}
read.csv("genus(origin).csv",row.names = 1,header = TRUE)->genus
t(genus)->genus
genus[match(rownames(genus2),rownames(genus)),]->genus
genus[,match(colnames(genus2),colnames(genus))]->genus
#otu<-genus
write.csv(genus,"dlkcsa.csv")
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
t(otu)->otu
otu[is.na(otu)]=0
meta1<-meta[,ncol(meta),drop=F]
tax<-matrix(0,nrow(otu),1)
rownames(tax)<-rownames(otu)
tax[,1]<-rownames(otu)
colnames(tax)<-'Genus'
OTU<-otu_table(otu,taxa_are_rows = T)
TAX<-tax_table(tax)
sample_meta<-sample_data(meta1)
physeq<-phyloseq(OTU,TAX,sample_meta)

library("ape")
random_tree = rtree(ntaxa(physeq), rooted=TRUE, tip.label=taxa_names(physeq))
#plot(random_tree)
physeq1 = merge_phyloseq(physeq, random_tree)
library(MicrobiotaProcess)
as.MPSE(physeq1)->physeq1
physeq1 %<>%mp_decostand(.abundance= Abundance )
physeq1 %>%mp_anosim(.abundance=hellinger,.group=Group,action="get" )
```


```{r}
######Male
library(phyloseq)
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
t(otu)->otu
otu[is.na(otu)]=0

meta[which(meta$Sex=="Male"),]->meta1
otu<-otu[,match(rownames(meta1),colnames(otu))]
meta1<-meta1[,ncol(meta1),drop=F]
tax<-matrix(0,nrow(otu),1)
rownames(tax)<-rownames(otu)
tax[,1]<-rownames(otu)
colnames(tax)<-'Genus'
OTU<-otu_table(otu,taxa_are_rows = T)
TAX<-tax_table(tax)
sample_meta<-sample_data(meta1)
physeq<-phyloseq(OTU,TAX,sample_meta)

library("ape")
random_tree = rtree(ntaxa(physeq), rooted=TRUE, tip.label=taxa_names(physeq))
#plot(random_tree)
physeq2 = merge_phyloseq(physeq, random_tree)
library(MicrobiotaProcess)
as.MPSE(physeq2)->physeq2
physeq2 %<>%mp_decostand(.abundance= Abundance )
physeq2 %>%mp_anosim(.abundance=hellinger,.group=Group,action="get" )
```

```{r}
######Female
library(phyloseq)
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
t(otu)->otu
otu[is.na(otu)]=0

meta[which(meta$Sex=="Female"),]->meta1
otu<-otu[,match(rownames(meta1),colnames(otu))]
meta1<-meta1[,ncol(meta1),drop=F]
tax<-matrix(0,nrow(otu),1)
rownames(tax)<-rownames(otu)
tax[,1]<-rownames(otu)
colnames(tax)<-'Genus'
OTU<-otu_table(otu,taxa_are_rows = T)
TAX<-tax_table(tax)
sample_meta<-sample_data(meta1)
physeq<-phyloseq(OTU,TAX,sample_meta)

library("ape")
random_tree = rtree(ntaxa(physeq), rooted=TRUE, tip.label=taxa_names(physeq))
#plot(random_tree)
physeq3 = merge_phyloseq(physeq, random_tree)
library(MicrobiotaProcess)
as.MPSE(physeq3)->physeq3
physeq3 %<>%mp_decostand(.abundance= Abundance )
physeq3 %>%mp_anosim(.abundance=hellinger,.group=Group,action="get" )
```

```{r}
library(ggplot2)
library(MicrobiotaProcess)
physeq1 %<>% 
  mp_cal_alpha(.abundance=Abundance,force=TRUE)
physeq1
f1 <- physeq1 %>% 
  mp_plot_alpha(
    .group=Group, 
    .alpha=c(Observe,Shannon, Simpson, Pielou)
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4"), guide="none") +
  scale_color_manual(values=c("#EB7369", "#5784C4"), guide="none")
desired_order <- c('Healthy','ASD')
Af1<-f1+ggtitle('A')+scale_x_discrete(limits=desired_order)


p3 <- physeq1 %>%
  mp_plot_abundance(
    .abundance=Abundance, 
    force = TRUE,
    .group = Group,
    taxa.class = Genus,
    topn = 20,
    plot.group = TRUE
  )
desired_order <- c('Healthy','ASD') 
Ap3<-p3+scale_x_discrete(limits=desired_order)+theme(legend.text = element_text(face = "italic"))+ggtitle('A') # 设置图表标题为斜体
Ap3



physeq1 %<>% 
  mp_decostand(.abundance=Abundance)
physeq1

physeq1 %<>% mp_cal_dist(.abundance=hellinger, distmethod="bray")
physeq1


p3 <- physeq1 %>% mp_plot_dist(.distmethod = bray, .group = Group, group.test=TRUE, textsize=2)
p3 +ggtitle('A')->distance_a
#ggsave(p3,filename = "样本间距离差异.pdf")

physeq1 %<>% 
  mp_cal_pcoa(.abundance=hellinger, distmethod="bray")
# The dimensions of ordination analysis will be added the colData slot (default).
physeq1

physeq1 %<>%
  mp_adonis(.abundance=hellinger, .formula=~Group, distmethod="bray", permutations=9999, action="add")
physeq1 %>% mp_extract_internal_attr(name=adonis)

library(ggplot2)
p1 <- physeq1 %>%
  mp_plot_ord(
    .ord = pcoa, 
    .group = Group, 
    .color = Group, 
    .size = 1.2,
    .alpha = 1,
    ellipse = TRUE,
    show.legend = FALSE # don't display the legend of stat_ellipse
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4")) +
  scale_color_manual(values=c("#EB7369", "#5784C4")) 
a<-p1+ggtitle('A')


physeq1 %<>%
  mp_cal_clust(
    .abundance = hellinger, 
    distmethod = "bray",
    hclustmethod = "average", # (UPGAE)
    action = "add" # action is used to control which result will be returned
  )
physeq1

sample.clust <- physeq1 %>% mp_extract_internal_attr(name='SampleClust')
sample.clust
library(ggtree)
p <- ggtree(sample.clust) + 
       geom_tippoint(aes(color=Group)) +
       geom_tiplab(as_ylab = TRUE) +
       ggplot2::scale_x_continuous(expand=c(0, 0.01))
p



```


```{r}
library(ggplot2)
library(MicrobiotaProcess)
physeq2 %<>% 
  mp_cal_alpha(.abundance=Abundance,force=TRUE)
physeq2
f1 <- physeq2 %>% 
  mp_plot_alpha(
    .group=Group, 
    .alpha=c(Observe,Shannon, Simpson, Pielou)
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4"), guide="none") +
  scale_color_manual(values=c("#EB7369", "#5784C4"), guide="none")
desired_order <- c('Healthy','ASD')
Bf1<-f1+ggtitle('B')+scale_x_discrete(limits=desired_order)


p3 <- physeq2 %>%
  mp_plot_abundance(
    .abundance=Abundance, 
    force = TRUE,
    .group = Group,
    taxa.class = Genus,
    topn = 20,
    plot.group = TRUE
  )
desired_order <- c('Healthy','ASD') 
Bp3<-p3+scale_x_discrete(limits=desired_order)+theme(legend.text = element_text(face = "italic"))+ggtitle('B') # 设置图表标题为斜体
Bp3



physeq2 %<>% 
  mp_decostand(.abundance=Abundance)
physeq2

physeq2 %<>% mp_cal_dist(.abundance=hellinger, distmethod="bray")
physeq2


p3 <- physeq2 %>% mp_plot_dist(.distmethod = bray, .group = Group, group.test=TRUE, textsize=2)
p3 +ggtitle('B')->distance_b
#ggsave(p3,filename = "样本间距离差异.pdf")

physeq2 %<>% 
  mp_cal_pcoa(.abundance=hellinger, distmethod="bray")
# The dimensions of ordination analysis will be added the colData slot (default).
physeq2

physeq2 %<>%
  mp_adonis(.abundance=hellinger, .formula=~Group, distmethod="bray", permutations=9999, action="add")
physeq2 %>% mp_extract_internal_attr(name=adonis)

library(ggplot2)
p1 <- physeq2 %>%
  mp_plot_ord(
    .ord = pcoa, 
    .group = Group, 
    .color = Group, 
    .size = 1.2,
    .alpha = 1,
    ellipse = TRUE,
    show.legend = FALSE # don't display the legend of stat_ellipse
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4")) +
  scale_color_manual(values=c("#EB7369", "#5784C4")) 
b<-p1+ggtitle('B')


physeq2 %<>%
  mp_cal_clust(
    .abundance = hellinger, 
    distmethod = "bray",
    hclustmethod = "average", # (UPGAE)
    action = "add" # action is used to control which result will be returned
  )
physeq2

```


```{r}
library(ggplot2)
library(MicrobiotaProcess)
physeq3 %<>% 
  mp_cal_alpha(.abundance=Abundance,force=TRUE)
physeq3
f1 <- physeq3 %>% 
  mp_plot_alpha(
    .group=Group, 
    .alpha=c(Observe,Shannon, Simpson, Pielou)
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4"), guide="none") +
  scale_color_manual(values=c("#EB7369", "#5784C4"), guide="none")
desired_order <- c('Healthy','ASD')
Cf1<-f1+ggtitle('C')+scale_x_discrete(limits=desired_order)



p3 <- physeq3 %>%
  mp_plot_abundance(
    .abundance=Abundance, 
    force = TRUE,
    .group = Group,
    taxa.class = Genus,
    topn = 20,
    plot.group = TRUE
  )
desired_order <- c('Healthy','ASD') 
Cp3<-p3+scale_x_discrete(limits=desired_order)+theme(legend.text = element_text(face = "italic"))+ggtitle('C') # 设置图表标题为斜体
Cp3



physeq3 %<>% 
  mp_decostand(.abundance=Abundance)
physeq3

physeq3 %<>% mp_cal_dist(.abundance=hellinger, distmethod="bray")
physeq3


p3 <- physeq3 %>% mp_plot_dist(.distmethod = bray, .group = Group, group.test=TRUE, textsize=2)
p3 +ggtitle('C')->distance_c
#ggsave(p3,filename = "样本间距离差异.pdf")

physeq3 %<>% 
  mp_cal_pcoa(.abundance=hellinger, distmethod="bray")
# The dimensions of ordination analysis will be added the colData slot (default).
physeq3

physeq3 %<>%
  mp_adonis(.abundance=hellinger, .formula=~Group, distmethod="bray", permutations=9999, action="add")
physeq3 %>% mp_extract_internal_attr(name=adonis)

library(ggplot2)
p1 <- physeq3 %>%
  mp_plot_ord(
    .ord = pcoa, 
    .group = Group, 
    .color = Group, 
    .size = 1.2,
    .alpha = 1,
    ellipse = TRUE,
    show.legend = FALSE # don't display the legend of stat_ellipse
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4")) +
  scale_color_manual(values=c("#EB7369", "#5784C4")) 
c<-p1+ggtitle('C')
```

```{r}
suppressPackageStartupMessages({
  library(SummarizedExperiment) # SummarizedExperiment container, a container contains one or more assays.
  library(MicrobiotaProcess) # an R tidy framework for microbiome or other related ecology data analysis.
  library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics.
  library(coin) # Conditional Inference Procedures in a Permutation Test Framework.
  library(ggnewscale) # Multiple Fill and Colour Scales in 'ggplot2'.
  library(forcats) # Helpers for reordering factor levels and tools for modifying factor levels.
  library(ggtree) # visualizing phylogenetic tree and heterogenous associated data based on grammar of graphics.
  library(ggtreeExtra) # plot associated data on the external layer based on grammar of graphics.
  library(clusterProfiler)
  library(enrichplot)
  library(MicrobiomeProfiler)
  library(curatedMetagenomicData)
  library(randomForest)
  library(curatedMetagenomicData)
  #library(phyloseq)
  library(ggtreeExtra)
  library(MicrobiotaProcess)
  library(ggtree)
  library(compositions)
  library(ggstar)
  library(vegan)
  library(pheatmap)
  library(ggplot2)
  library(ggpubr)
  library(ggsignif)
  library(tidyverse)
  library(ggprism)
  library(reshape2)
})

#####发育树
####整体
setwd("D:\\360安全浏览器下载\\课题\\6月份\\根据菌群距离选择健康样本")
abundance<-read.csv('dlkcsa.csv',row.names = 1)
abundance<-t(abundance)%>%as.data.frame()
meta<-read.csv('meta.csv',row.names = 1)
colnames(meta)[ncol(meta)]<-"Group"
data(hmp_aerobiosis_small)
taxda$Genus<-gsub('g__','',taxda$Genus)
taxda1<-taxda
rownames(taxda1)<-taxda1$Genus
taxda1<-taxda1[intersect(rownames(taxda1),rownames(abundance)),]
abundance<-abundance[intersect(rownames(taxda1),rownames(abundance)),]
treedata<-convert_to_treedata(taxda1)
OTU<-phyloseq::otu_table(abundance,taxa_are_rows = T)
TAX<-phyloseq::tax_table(taxda1%>%as.matrix())
meta1<-phyloseq::sample_data(meta)
physeq<-phyloseq(OTU,meta1)
physeq1<-as.MPSE(physeq)
physeq1@taxatree<-treedata
physeq1 %<>% 
  mp_decostand(.abundance=Abundance)
physeq1 %>% 
  mp_anosim(.abundance=Abundance, .group=Group, action="get")





physeq1 %<>%
  mp_diff_analysis(
    .abundance = hellinger,
    force = T,
    .group = Disease,
    first.test.alpha = 0.01
  )
physeq1 %<>%
  mp_cal_abundance( # for each samples
    .abundance = Abundance,
    force = T
  ) %>%
  mp_cal_abundance( # for each groups 
    .abundance=Abundance,
    .group=Disease,
    force = T
  )
physeq1
p <- physeq1 %>%
  mp_plot_diff_res(
    group.abun = TRUE,
    pwidth.abun=0.1
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4")) +
  scale_fill_manual(
    aesthetics = "fill_new", # The fill aes was renamed to "fill_new" for the abundance dotplot layer
    values = c("#EB7369", "#5784C4")
  ) +
  scale_fill_manual(
    aesthetics = "fill_new_new", # The fill aes for hight light layer of tree was renamed to 'fill_new_new'
    values = c('#e6194B', '#3cb44b', '#ffe119',
               '#4363d8', '#f58231', '#42d4f4', 
               '#f032e6', '#fabed4', '#469990', 
               '#dcbeff', '#9A6324', '#fffac8', 
               '#800000', '#aaffc3', '#000075', 
               '#a9a9a9', '#ffffff', '#000000',
               '#111111'
    )
  )
p
ggsave("y叔包.pdf",p,height = 40,width = 40,units = "cm")

####男性
setwd("D:\\360安全浏览器下载\\课题\\6月份\\根据菌群距离选择健康样本")
abundance<-read.csv('dlkcsa.csv',row.names = 1)
abundance<-t(abundance)%>%as.data.frame()
meta<-read.csv('meta.csv',row.names = 1)
#colnames(meta)[ncol(meta)]<-"Group"

####Male
meta[which(meta$Sex=="Male"),]->meta
abundance[,match(rownames(meta),colnames(abundance))]->abundance
data(hmp_aerobiosis_small)
taxda$Genus<-gsub('g__','',taxda$Genus)
taxda1<-taxda
rownames(taxda1)<-taxda1$Genus
taxda1<-taxda1[intersect(rownames(taxda1),rownames(abundance)),]
abundance<-abundance[intersect(rownames(taxda1),rownames(abundance)),]
treedata<-convert_to_treedata(taxda1)

OTU<-phyloseq::otu_table(abundance,taxa_are_rows = T)
TAX<-phyloseq::tax_table(taxda1%>%as.matrix())
meta1<-phyloseq::sample_data(meta)
physeq<-phyloseq(OTU,meta1)
physeq1<-as.MPSE(physeq)
physeq1@taxatree<-treedata
physeq1 %<>% 
  mp_decostand(.abundance=Abundance)
physeq1 %>% 
  mp_anosim(.abundance=Abundance, .group=Group, action="get")


physeq1 %<>%
  mp_diff_analysis(
    .abundance = hellinger,
    force = T,
    .group = Group,
    first.test.alpha = 0.01
  )
physeq1 %<>%
  mp_cal_abundance( # for each samples
    .abundance = Abundance,
    force = T
  ) %>%
  mp_cal_abundance( # for each groups 
    .abundance=Abundance,
    .group=Group,
    force = T
  )
physeq1
p <- physeq1 %>%
  mp_plot_diff_res(
    group.abun = TRUE,
    pwidth.abun=0.1
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4")) +
  scale_fill_manual(
    aesthetics = "fill_new", # The fill aes was renamed to "fill_new" for the abundance dotplot layer
    values = c("#EB7369", "#5784C4")
  ) +
  scale_fill_manual(
    aesthetics = "fill_new_new", # The fill aes for hight light layer of tree was renamed to 'fill_new_new'
    values = c('#e6194B', '#3cb44b', '#ffe119',
               '#4363d8', '#f58231', '#42d4f4', 
               '#f032e6', '#fabed4', '#469990', 
               '#dcbeff', '#9A6324', '#fffac8', 
               '#800000', '#aaffc3', '#000075', 
               '#a9a9a9', '#ffffff', '#000000',
               '#111111'
    )
  )
p
ggsave("男性发育树.pdf",p,height = 40,width = 40,units = "cm")



####女性

setwd("D:\\360安全浏览器下载\\课题\\6月份\\根据菌群距离选择健康样本")
abundance<-read.csv('dlkcsa.csv',row.names = 1)
abundance<-t(abundance)%>%as.data.frame()
meta<-read.csv('meta.csv',row.names = 1)
#colnames(meta)[ncol(meta)]<-"Group"

####Male
meta[which(meta$Sex=="Female"),]->meta
abundance[,match(rownames(meta),colnames(abundance))]->abundance
data(hmp_aerobiosis_small)
taxda$Genus<-gsub('g__','',taxda$Genus)
taxda1<-taxda
rownames(taxda1)<-taxda1$Genus
taxda1<-taxda1[intersect(rownames(taxda1),rownames(abundance)),]
abundance<-abundance[intersect(rownames(taxda1),rownames(abundance)),]
treedata<-convert_to_treedata(taxda1)

OTU<-phyloseq::otu_table(abundance,taxa_are_rows = T)
TAX<-phyloseq::tax_table(taxda1%>%as.matrix())
meta1<-phyloseq::sample_data(meta)
physeq<-phyloseq(OTU,meta1)
physeq1<-as.MPSE(physeq)
physeq1@taxatree<-treedata
physeq1 %<>% 
  mp_decostand(.abundance=Abundance)
physeq1 %>% 
  mp_anosim(.abundance=Abundance, .group=Group, action="get")


physeq1 %<>%
  mp_diff_analysis(
    .abundance = hellinger,
    force = T,
    .group = Group,
    first.test.alpha = 0.01
  )
physeq1 %<>%
  mp_cal_abundance( # for each samples
    .abundance = Abundance,
    force = T
  ) %>%
  mp_cal_abundance( # for each groups 
    .abundance=Abundance,
    .group=Group,
    force = T
  )
physeq1
p <- physeq1 %>%
  mp_plot_diff_res(
    group.abun = TRUE,
    pwidth.abun=0.1
  ) +
  scale_fill_manual(values=c("#EB7369", "#5784C4")) +
  scale_fill_manual(
    aesthetics = "fill_new", # The fill aes was renamed to "fill_new" for the abundance dotplot layer
    values = c("#EB7369", "#5784C4")
  ) +
  scale_fill_manual(
    aesthetics = "fill_new_new", # The fill aes for hight light layer of tree was renamed to 'fill_new_new'
    values = c('#e6194B', '#3cb44b', '#ffe119',
               '#4363d8', '#f58231', '#42d4f4', 
               '#f032e6', '#fabed4', '#469990', 
               '#dcbeff', '#9A6324', '#fffac8', 
               '#800000', '#aaffc3', '#000075', 
               '#a9a9a9', '#ffffff', '#000000',
               '#111111'
    )
  )
p
ggsave("女性发育树.pdf",p,height = 40,width = 40,units = "cm")
```





```{r}
a+b+c
distance_a+distance_b+distance_c
Af1+Bf1+Cf1
```



```{r}
setwd("D:\\360安全浏览器下载\\课题\\6月份\\MICOM\\agora103_genus\\890088c4-1a67-498b-8a54-3eb31ee06f63\\data")
filenames<-list.files()
for(i in 1:length(filenames)){
  filenames[i]<-substr(filenames[i],1,nchar(filenames[i])-5)
}

library(phyloseq)
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
t(otu)->otu
otu[is.na(otu)]=0
species_name<-colnames(otu)
#write.csv(species_name,"species.csv")
#read.csv("species.csv",header = FALSE)->species_name

#species_name<-colnames(species)
as.matrix(species_name)->species_name
colnames(species_name)<-"species_name"
rownames(species_name)<-species_name[,1]
#t(otu)->otu
otu[intersect(rownames(otu),filenames),]->match_species
species_name<-rownames(match_species)
#####all
rep(species_name, times=ncol(match_species))->species_name1
as.matrix(species_name1)->species_name1
sample_name<-colnames(match_species)
rep(sample_name, each=nrow(match_species))->sample_name1
as.matrix(sample_name1)->sample_name1


c(match_species[,1],match_species[,2])->match_species1
for (i in 3:ncol(match_species)) {
  c(match_species1,match_species[,i])->match_species1
  i=i+1
}
as.matrix(match_species1)->match_species1
cbind(species_name1,sample_name1,match_species1,species_name1)->data
colnames(data)<-c('id','sample_id','abundance','genus')
write.csv(data,"data.csv")

####Male

read.csv("meta.csv",row.names = 1,header = T)->meta
match_species[,match(rownames(meta)[which(meta$Sex=="Male")],colnames(match_species))]->match_species_male
rep(species_name, times=ncol(match_species_male))->species_name1
as.matrix(species_name1)->species_name1
sample_name<-colnames(match_species_male)
rep(sample_name, each=nrow(match_species_male))->sample_name1
as.matrix(sample_name1)->sample_name1


c(match_species_male[,1],match_species_male[,2])->match_species1
for (i in 3:ncol(match_species_male)) {
  c(match_species1,match_species_male[,i])->match_species1
  i=i+1
}
as.matrix(match_species1)->match_species1
cbind(species_name1,sample_name1,match_species1,species_name1)->data
colnames(data)<-c('id','sample_id','abundance','genus')
write.csv(data,"Male_micom.csv")





read.csv("Male_micom.csv",header = T)->M
M<-cbind(M,meta$Disease[match(M$sample_id,rownames(meta))])
write.csv(M,"Male_micom.csv")


###Female
match_species[,match(rownames(meta)[which(meta$Sex=="Female")],colnames(match_species))]->match_species_female

rep(species_name, times=ncol(match_species_female))->species_name1
as.matrix(species_name1)->species_name1
sample_name<-colnames(match_species_female)
rep(sample_name, each=nrow(match_species_female))->sample_name1
as.matrix(sample_name1)->sample_name1


c(match_species_female[,1],match_species_female[,2])->match_species1
for (i in 3:ncol(match_species_female)) {
  c(match_species1,match_species_female[,i])->match_species1
  i=i+1
}
as.matrix(match_species1)->match_species1
cbind(species_name1,sample_name1,match_species1,species_name1)->data
colnames(data)<-c('id','sample_id','abundance','genus')
write.csv(data,"Female_micom.csv")
read.csv("Female_micom.csv",header = T)->F
read.csv("meta.csv",header = T,row.names = 1)->meta
F<-cbind(F,meta$Disease[match(F$sample_id,rownames(meta))])
write.csv(F,"Female_micom.csv")
```



```{r}
spetax <-otu

cbind(rownames(meta),rownames(meta),meta$Sex,meta$Group)->group
colnames(group)<-c("Sample","name","Sex","Group")
#t(spetax)->spetax


#Genus<-rownames(spetax)
#cbind(Genus,spetax)->spetax
#head(spetax)


read.csv("manifest.csv",header = TRUE,row.names = 1)->tax
as.data.frame(spetax)->spetax
tax[match(rownames(spetax),tax$genus),]->tax1
na.omit(tax1)->tax1    
spetax[match(rownames(tax1),rownames(spetax)),]->spetax1
## 将物种分类单元注释信息与丰度数据分开
tax <- tax1
spe <- spetax1
head(spe)
head(tax)
as.data.frame(group)->group
## 样本分组数据
group$group <- factor(group$Group,levels = c("Healthy","ASD"))
colnames(group)[3:4]<-c("Sex","Group")

# 2.1.1 物种组成数据按照门进行汇总
## spe和tax数据表中物种排序一致
library(tidyverse)
apply(spe,2, as.numeric)->spe1
as.data.frame(spe1)->spe1
rownames(spe1)<-rownames(spe)
phy <- spe1 %>%
  group_by(tax$phylum) %>% # 使用tax中的门水平进行分类
  summarise_all(sum) %>%
  rename(phylum = `tax$phylum`) %>%
  gather(key="Samples",value = "abun",-phylum) %>% # 数据形式转换：“宽”转“长”
  left_join(group,by=c("Samples"="name")) %>%
  select(group,Sex,phylum,abun) %>%
  group_by(group,Sex,phylum) %>% # 求均值
  summarise_all(mean)

dim(phy)
head(phy)

# 2.1.2 颜色
library(ggsci)
col=pal_d3("category20")(20)
col2 = pal_d3("category20",alpha = 0.5)(20)
mypal=c(col,col2[-8])

# 2.1.3  物种组成堆叠柱形图-绝对丰度
library(ggplot2)
pdf("abs_stack.pdf",width = 12,height = 10,family="Times")
ggplot()+
  geom_bar(data=phy,
           aes(x=group,
               weight=abun,
               fill=reorder(phylum,-abun)),
           position = "stack",# 百分比堆叠图position = "fill"
           width=0.5)+
  facet_grid(.~Sex)+
  scale_fill_manual(values = mypal[-18])+
  theme_bw()+
  guides(fill=guide_legend(title = "phylum",ncol = 2))+
  labs(y = "Absolute abundance",x=NULL)+
  theme(legend.position="right",
        axis.title = element_text(face = "bold", 
                                  size = 12,colour = "black"))+
  theme(axis.text = element_text(face = "bold", 
                                 size = 10,color="black"),
        strip.text.x = element_text(face = "bold", 
                                    size =12,color="black"))+
  theme(panel.grid=element_blank())+
  theme(legend.title = element_text(face = "bold", 
                                    size =12,color="black"),
        legend.text = element_text(face = "bold", 
                                   size =10,color="black"))
dev.off()
```
```{r}
library(ggthemes)
desired_order <- c('Male','Female')
# 2.2.1  物种组成堆叠柱形图-相对丰度
pdf("rel_stack.pdf",width = 12,height = 10,family="Times")
ggplot()+
  geom_bar(data=phy,
           aes(x=group,
               weight=abun,
               fill=reorder(phylum,-abun)),
           position = "fill", # ggplot2会自行计算相对丰度，无需提前计算。
           width=0.5)+
  facet_grid(.~Sex)+
  scale_fill_manual(values = mypal[-18])+ # 颜色与绝对丰度堆叠柱形图保持一致
  theme_base()+
  scale_y_continuous(#expand=c(0,0), #设置横坐标轴紧挨柱形图
    name = "Relative abundance (%)",
    limits = c(0,1),
    breaks = seq(0,1,0.25),
    labels = paste(seq(0,100,25),"%")
  )+
  guides(fill=guide_legend(title = "phylum",ncol = 2))+
  labs(x=NULL)+
  theme(legend.position="right",
        axis.title = element_text(face = "bold", 
                                  size = 12,colour = "black"))+
  theme(axis.text = element_text(face = "bold", 
                                 size = 10,color="black"),
        strip.text.x = element_text(face = "bold", 
                                    size =12,color="black"))+
  theme(panel.grid=element_blank())+
  theme(legend.title = element_text(face = "bold", 
                                    size =12,color="black"),
        legend.text = element_text(face = "bold", 
                                   size =10,color="black"))
dev.off()

```




```{r}
####线性判别分析
#BiocManager::install("pacman")
library(pacman)
pacman::p_load(tidyverse,microeco,magrittr)
feature_table<-otu###菌为行
sample_table<-group[,c(1,4)]
colnames(sample_table)[1]<-"SampleID"
rownames(sample_table)<-sample_table$SampleID
tax_table<-read.csv("manifest1.csv",header = TRUE,row.names = 1)
tax_table[match(rownames(feature_table),tax_table$genus),]->tax_table
na.omit(tax_table)->tax_table
feature_table[match(tax_table$genus,rownames(feature_table)),]->feature_table
as.data.frame(tax_table)->tax_table
as.data.frame(feature_table)->feature_table
as.data.frame(sample_table)->sample_table
sample_table$Group[which(sample_table$Group=="Healthy")]<-"Health"

# 创建microtable对象
dataset <- microtable$new(sample_table = sample_table,
                          otu_table = feature_table, 
                          tax_table = tax_table)
dataset

# 执行lefse分析
lefse <- trans_diff$new(dataset = dataset, 
                        method = "lefse", 
                        group = "Group", 
                        alpha = 0.1, 
                        lefse_subgroup = NULL)

# 查看分析结果
head(lefse$res_diff)


# 绘制前30个具有最高LDA（log10）的分类单元的差异特征柱状图
A<-lefse$plot_diff_bar(use_number = 1:10, 
                       width = 0.8, 
                       group_order = c("ASD", "Health")) +
  ggsci::scale_color_npg() +
  ggsci::scale_fill_npg()+
  ggtitle('A')+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))


# 展示前200个分类单元和前50个特征
# 需要调用ggtree包
ATREE<-lefse$plot_diff_cladogram(use_taxa_num = 200, 
                                 use_feature_num = 150, 
                                 clade_label_level = 5, 
                                 group_order = c("ASD", "Health"))+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
use_labels <- c("Proteobacteria","Gammaproteobacteria","Pseudomonadales",'Pseudomonadaceae'   ,'Pseudomonas','Barnesiella','Methanobacteria','Methanobacteriales','Methanobacteriaceae','Methanobrevibacter')
ATREE<-lefse$plot_diff_cladogram(use_taxa_num = 20, 
             use_feature_num = 100, 
            select_show_labels = use_labels)



ggsave("发育树(总).pdf",ATREE,height = 30,width = 30,units = "cm")


as.data.frame(meta)->meta
######Male
feature_table[,match(rownames(meta)[which(meta$Sex=="Male")],colnames(feature_table))]->Male_feature_table
sample_table[match(rownames(meta)[which(meta$Sex=="Male")],rownames(sample_table)),]->Male_sample_table

which(rownames(Male_feature_table)==0)
# 创建microtable对象
Male_dataset <- microtable$new(sample_table = Male_sample_table,
                              otu_table = Male_feature_table, 
                              tax_table = tax_table)
Male_dataset



# 执行lefse分析
lefse <- trans_diff$new(dataset = Male_dataset, 
                        method = "lefse", 
                        group = "Group", 
                        alpha = 0.1, 
                        lefse_subgroup = NULL)

# 绘制前30个具有最高LDA（log10）的分类单元的差异特征柱状图
B<-lefse$plot_diff_bar(use_number = 1:9, 
                       width = 0.8, 
                       group_order = c("ASD", "Health")) +
  ggsci::scale_color_npg() +
  ggsci::scale_fill_npg()+
  ggtitle('B')+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))


# 展示前200个分类单元和前50个特征
# 需要调用ggtree包
BTREE<-lefse$plot_diff_cladogram(use_taxa_num = 100, 
                                 use_feature_num = 50, 
                                 clade_label_level = 5, 
                                 group_order = c("ASD", "Health"))+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
use_labels <- B$data$Taxa%>%as.character()
BTREE<-lefse$plot_diff_cladogram(use_taxa_num = 50, 
             use_feature_num =100, 
            select_show_labels = use_labels)+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))



######Female
feature_table[,match(rownames(meta)[which(meta$Sex=="Female")],colnames(feature_table))]->Female_feature_table
sample_table[match(rownames(meta)[which(meta$Sex=="Female")],rownames(sample_table)),]->Female_sample_table

which(rownames(Female_feature_table)==0)
# 创建microtable对象
Female_dataset <- microtable$new(sample_table = Female_sample_table,
                              otu_table = Female_feature_table, 
                              tax_table = tax_table)
Female_dataset



# 执行lefse分析
lefse <- trans_diff$new(dataset = Female_dataset, 
                        method = "lefse", 
                        group = "Group", 
                        alpha = 0.1, 
                        lefse_subgroup = NULL)

# 绘制前30个具有最高LDA（log10）的分类单元的差异特征柱状图
C<-lefse$plot_diff_bar(use_number = 1:9, 
                       width = 0.8, 
                       group_order = c("ASD", "Health")) +
  ggsci::scale_color_npg() +
  ggsci::scale_fill_npg()+
  ggtitle('C')+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
A$data$Taxa
B$data$Taxa
C$data$Taxa


CTREE<-lefse$plot_diff_cladogram(use_taxa_num = 200, 
                                 use_feature_num = 150, 
                                 clade_label_level = 5, 
                                 group_order = c("ASD", "Health"))+scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
use_labels <- C$data$Taxa
CTREE<-lefse$plot_diff_cladogram(use_taxa_num = 50, 
             use_feature_num = 100, 
            select_show_labels = use_labels)



ggsave("发育树(女性).pdf",CTREE,height = 30,width = 30,units = "cm")
```
```{r}
#######生长速率
read.csv("growth_rates (3).csv",header = TRUE)->data
taxon<-unique(data$taxon)
sampleid<-unique(data$sample_id)
growth_rates<-matrix(0,length(taxon),length(sampleid))
rownames(growth_rates)<-taxon
colnames(growth_rates)<-sampleid
for(i in 1:nrow(growth_rates)){
  temp<-data[which(data$taxon==rownames(growth_rates)[i]),]
  growth_rates[i,match(temp$sample_id,colnames(growth_rates))]<-temp$growth_rate
}
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
growth_rates[,match(rownames(meta)[which(meta$Group=="ASD")],colnames(growth_rates))]->ASD
growth_rates[,match(rownames(meta)[which(meta$Group=="Health")],colnames(growth_rates))]->Healthy
t(ASD)->ASD
t(Healthy)->Healthy
p<-c()
for (i in 1:length(ASD[1,])) {
  wilcox.test(ASD[,i],Healthy[,i])$p.val->p[i]
}
as.matrix(p)->p11
rownames(p11)<-rownames(growth_rates)

growth_rates[which(rownames(growth_rates)=="Pseudomonas"|rownames(growth_rates)=="Bacillus"|rownames(growth_rates)=="Intestinibacter"|rownames(growth_rates)=="Pseudoflavonifractor"|rownames(growth_rates)=="Staphylococcus"),]->sign_taxon
a1<-c()
for (i in 1:nrow(sign_taxon)) {
c(a1,which(data$taxon==rownames(sign_taxon)[i]))->a1
}
data[a1,]->sign_growth
sign_growth<-cbind(sign_growth,meta$Group[match(sign_growth$sample_id,rownames(meta))])
colnames(sign_growth)[ncol(sign_growth)]<-"Group"
#sign_growth$Group[which(sign_growth$Group=="Healthy")]<-"Health"
p<-ggplot(sign_growth, aes(x = growth_rate, y = taxon, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "taxon") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
p1<-p+ggtitle('A')







read.csv("growth_rates (3).csv",header = TRUE)->data
taxon<-unique(data$taxon)
sampleid<-unique(data$sample_id)
growth_rates<-matrix(0,length(taxon),length(sampleid))
rownames(growth_rates)<-taxon
colnames(growth_rates)<-sampleid
for(i in 1:nrow(growth_rates)){
  temp<-data[which(data$taxon==rownames(growth_rates)[i]),]
  growth_rates[i,match(temp$sample_id,colnames(growth_rates))]<-temp$growth_rate
}
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
Male_growth<-growth_rates[,match(rownames(meta)[which(meta$Sex=="Male")],colnames(growth_rates))]
Female_growth<-growth_rates[,match(rownames(meta)[which(meta$Sex=="Female")],colnames(growth_rates))]
meta[match(colnames(Male_growth),rownames(meta)),]->Male_meta
meta[match(colnames(Female_growth),rownames(meta)),]->Female_meta


Male_growth[,match(rownames(Male_meta)[which(Male_meta$Group=="ASD")],colnames(Male_growth))]->ASD
Male_growth[,match(rownames(Male_meta)[which(Male_meta$Group=="Health")],colnames(Male_growth))]->Healthy
t(ASD)->ASD
t(Healthy)->Healthy
p<-c()
for (i in 1:length(ASD[1,])) {
  wilcox.test(ASD[,i],Healthy[,i])$p.val->p[i]
}
as.matrix(p)->p22
rownames(p22)<-rownames(Male_growth)

Male_growth[which(rownames(Male_growth)=="Pseudomonas"|rownames(Male_growth)=="Pseudoflavonifractor"|rownames(Male_growth)=="Bacillus"|rownames(Male_growth)=="Prevotella"|rownames(Male_growth)=="Neisseria"),]->sign_taxon
a1<-c()
for (i in 1:nrow(sign_taxon)) {
c(a1,which(data$taxon==rownames(sign_taxon)[i]))->a1
}
data[a1,]->sign_growth
sign_growth<-cbind(sign_growth,Male_meta$Group[match(sign_growth$sample_id,rownames(Male_meta))])
colnames(sign_growth)[ncol(sign_growth)]<-"Group"
na.omit(sign_growth)->sign_growth
#sign_growth$Group[which(sign_growth$Group=="Healthy")]<-"Health"
p<-ggplot(sign_growth, aes(x = growth_rate, y = taxon, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "taxon") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
p2<-p+ggtitle('B')







Female_growth[,match(rownames(Female_meta)[which(Female_meta$Group=="ASD")],colnames(Female_growth))]->ASD
Female_growth[,match(rownames(Female_meta)[which(Female_meta$Group=="Health")],colnames(Female_growth))]->Healthy
t(ASD)->ASD
t(Healthy)->Healthy
p<-c()
for (i in 1:length(ASD[1,])) {
  wilcox.test(ASD[,i],Healthy[,i])$p.val->p[i]
}
as.matrix(p)->p33
rownames(p33)<-rownames(Female_growth)

Female_growth[which(rownames(Female_growth)=="Pseudomonas"|rownames(Female_growth)=="Acinetobacter"|rownames(Female_growth)=="Intestinibacter"|rownames(Female_growth)=="Providencia"|rownames(Female_growth)=="Bacillus"),]->sign_taxon
a1<-c()
for (i in 1:nrow(sign_taxon)) {
c(a1,which(data$taxon==rownames(sign_taxon)[i]))->a1
}
data[a1,]->sign_growth
sign_growth<-cbind(sign_growth,Female_meta$Group[match(sign_growth$sample_id,rownames(Female_meta))])
colnames(sign_growth)[ncol(sign_growth)]<-"Group"
na.omit(sign_growth)->sign_growth
#sign_growth$Group[which(sign_growth$Group=="Healthy")]<-"Health"
p<-ggplot(sign_growth, aes(x = growth_rate, y = taxon, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "taxon") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
p3<-p+ggtitle('C')



as.data.frame(p22)->p22
as.data.frame(p33)->p33
library(tidyverse)
rownames(p22)[which(p22[,1]<0.05)]->p222
rownames(p33)[which(p33[,1]<0.05)]->p333


na.omit(p333[match(p222,p333)])->a
a

read.csv("growth_rates (3).csv",header = TRUE)->data
taxon<-unique(data$taxon)
sampleid<-unique(data$sample_id)
growth_rates<-matrix(0,length(taxon),length(sampleid))
rownames(growth_rates)<-taxon
colnames(growth_rates)<-sampleid
for(i in 1:nrow(growth_rates)){
  temp<-data[which(data$taxon==rownames(growth_rates)[i]),]
  growth_rates[i,match(temp$sample_id,colnames(growth_rates))]<-temp$growth_rate
}
growth_rates[match(a,rownames(growth_rates)),]->growth_rates
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
Male_growth<-growth_rates[,match(rownames(meta)[which(meta$Sex=="Male")],colnames(growth_rates))]
Female_growth<-growth_rates[,match(rownames(meta)[which(meta$Sex=="Female")],colnames(growth_rates))]
meta[match(colnames(Male_growth),rownames(meta)),]->Male_meta
meta[match(colnames(Female_growth),rownames(meta)),]->Female_meta

a1<-c()
for (i in 1:nrow(Male_growth)) {
c(a1,which(data$taxon==rownames(Male_growth)[i]))->a1
}
data[a1,]->Male_growth
Male_growth<-cbind(Male_growth,Male_meta$Group[match(Male_growth$sample_id,rownames(Male_meta))])
colnames(Male_growth)[ncol(Male_growth)]<-"Group"
na.omit(Male_growth)->Male_growth


a1<-c()
for (i in 1:nrow(Female_growth)) {
c(a1,which(data$taxon==rownames(Female_growth)[i]))->a1
}
data[a1,]->Female_growth
Female_growth<-cbind(Female_growth,Female_meta$Group[match(Female_growth$sample_id,rownames(Female_meta))])
colnames(Female_growth)[ncol(Female_growth)]<-"Group"
na.omit(Female_growth)->Female_growth


Male_growth[which(Male_growth$taxon=="Acinetobacter"),]->Acinetobacter1
cbind(Acinetobacter1,rep("Male",length(Acinetobacter1[,1])))->Acinetobacter11
colnames(Acinetobacter11)[ncol(Acinetobacter11)]<-"Sex"
Female_growth[which(Female_growth$taxon=="Acinetobacter"),]->Acinetobacter2
cbind(Acinetobacter2,rep("Female",length(Acinetobacter2[,1])))->Acinetobacter22
colnames(Acinetobacter22)[ncol(Acinetobacter22)]<-"Sex"
rbind(Acinetobacter11,Acinetobacter22)->Acinetobacter_all
desired_order <- c('Male','Female')
p1<-ggplot(Acinetobacter_all, aes(x = Sex, y = growth_rate, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "Sex", y = "growth_rate") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+scale_x_discrete(limits=desired_order)+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ ggtitle("Acinetobacter")+ 
  theme(plot.title.position = "plot")



Male_growth[which(Male_growth$taxon=="Bacillus"),]->Bacillus1
cbind(Bacillus1,rep("Male",length(Bacillus1[,1])))->Bacillus11
colnames(Bacillus11)[ncol(Bacillus11)]<-"Sex"
Female_growth[which(Female_growth$taxon=="Bacillus"),]->Bacillus2
cbind(Bacillus2,rep("Female",length(Bacillus2[,1])))->Bacillus22
colnames(Bacillus22)[ncol(Bacillus22)]<-"Sex"
rbind(Bacillus11,Bacillus22)->Bacillus_all
desired_order <- c('Male','Female')
p2<-ggplot(Bacillus_all, aes(x = Sex, y = growth_rate, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "Sex", y = "growth_rate") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+scale_x_discrete(limits=desired_order)+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ ggtitle("Bacillus")+ 
  theme(plot.title.position = "plot")
p2






Male_growth[which(Male_growth$taxon=="Pseudomonas"),]->Pseudomonas1
cbind(Pseudomonas1,rep("Male",length(Pseudomonas1[,1])))->Pseudomonas11
colnames(Pseudomonas11)[ncol(Pseudomonas11)]<-"Sex"
Female_growth[which(Female_growth$taxon=="Pseudomonas"),]->Pseudomonas2
cbind(Pseudomonas2,rep("Female",length(Pseudomonas2[,1])))->Pseudomonas22
colnames(Pseudomonas22)[ncol(Pseudomonas22)]<-"Sex"
rbind(Pseudomonas11,Pseudomonas22)->Pseudomonas_all
desired_order <- c('Male','Female')
p3<-ggplot(Pseudomonas_all, aes(x = Sex, y = growth_rate, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "Sex", y = "growth_rate") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+scale_x_discrete(limits=desired_order)+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ ggtitle("Pseudomonas")+ 
  theme(plot.title.position = "plot")
p3






Male_growth[which(Male_growth$taxon=="Staphylococcus"),]->Staphylococcus1
cbind(Staphylococcus1,rep("Male",length(Staphylococcus1[,1])))->Staphylococcus11
colnames(Staphylococcus11)[ncol(Staphylococcus11)]<-"Sex"
Female_growth[which(Female_growth$taxon=="Staphylococcus"),]->Staphylococcus2
cbind(Staphylococcus2,rep("Female",length(Staphylococcus2[,1])))->Staphylococcus22
colnames(Staphylococcus22)[ncol(Staphylococcus22)]<-"Sex"
rbind(Staphylococcus11,Staphylococcus22)->Staphylococcus_all
desired_order <- c('Male','Female')
p4<-ggplot(Staphylococcus_all, aes(x = Sex, y = growth_rate, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "Sex", y = "growth_rate") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+scale_x_discrete(limits=desired_order)+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ ggtitle("Staphylococcus")+ 
  theme(plot.title.position = "plot")
p4
```
```{r}
p22[match(rownames(p11),rownames(p22)),]->p22
p33[match(rownames(p11),rownames(p33)),]->p33
cbind(p11,p22,p33)->p11
as.data.frame(p11)->p11
#write.csv(p11,"p11.csv")
read.csv("p11.csv",row.names = 1)->p11
rownames(p11)->a



Female_growth[match(a,rownames(Female_growth)),]->sign_taxon
a1<-c()
for (i in 1:nrow(sign_taxon)) {
c(a1,which(data$taxon==rownames(sign_taxon)[i]))->a1
}
data[a1,]->sign_growth
sign_growth<-cbind(sign_growth,Female_meta$Group[match(sign_growth$sample_id,rownames(Female_meta))])
colnames(sign_growth)[ncol(sign_growth)]<-"Group"
na.omit(sign_growth)->sign_growth
#sign_growth$Group[which(sign_growth$Group=="Healthy")]<-"Health"
p<-ggplot(sign_growth, aes(x = growth_rate, y = taxon, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "taxon") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
p3<-p+ggtitle('C')





Male_growth[match(a,rownames(Male_growth)),]->sign_taxon
a1<-c()
for (i in 1:nrow(sign_taxon)) {
c(a1,which(data$taxon==rownames(sign_taxon)[i]))->a1
}
data[a1,]->sign_growth
sign_growth<-cbind(sign_growth,Male_meta$Group[match(sign_growth$sample_id,rownames(Male_meta))])
colnames(sign_growth)[ncol(sign_growth)]<-"Group"
na.omit(sign_growth)->sign_growth
#sign_growth$Group[which(sign_growth$Group=="Healthy")]<-"Health"
p<-ggplot(sign_growth, aes(x = growth_rate, y = taxon, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "taxon") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
p2<-p+ggtitle('B')









growth_rates[match(a,rownames(growth_rates)),]->sign_taxon
a1<-c()
for (i in 1:nrow(sign_taxon)) {
c(a1,which(data$taxon==rownames(sign_taxon)[i]))->a1
}
data[a1,]->sign_growth
sign_growth<-cbind(sign_growth,meta$Group[match(sign_growth$sample_id,rownames(meta))])
colnames(sign_growth)[ncol(sign_growth)]<-"Group"
p<-ggplot(sign_growth, aes(x = growth_rate, y = taxon, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "taxon") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
p1<-p+ggtitle('A')


p1+p2+p3




```


```{r}
library(tidyverse)
library(palmerpenguins)
background <- function() {
  grobTree(
    rectGrob(y = 0.75, x = 0.5, width = 1, height = 0.5, gp = gpar(fill = "yellow", alpha = 0.2)),
    rectGrob(y = 0.25, x = 0.5, width = 1, height = 0.5, gp = gpar(fill = "green", alpha = 0.2))
  )
}

cbind(sign_growth,meta$Sex[match(sign_growth$sample_id,rownames(meta))])->sign_growth
colnames(sign_growth)[ncol(sign_growth)]<-"Sex"
sign_growth[,c(1,4,5,6)]->sign_growth
```


```{r}
table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Bacillus"),]->Bacillus
p1<-ggplot(Bacillus, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Bacillus") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Bacillus.pdf",p1,height = 3,width = 15,units = "cm")





table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Collinsella"),]->Collinsella
p1<-ggplot(Collinsella, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Collinsella") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Collinsella.pdf",p1,height = 5,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Coprococcus"),]->Coprococcus
p1<-ggplot(Coprococcus, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Coprococcus") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Coprococcus.pdf",p1,height = 3,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Corynebacterium"),]->Corynebacterium
p1<-ggplot(Corynebacterium, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Corynebacterium") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Corynebacterium.pdf",p1,height = 3,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Dorea"),]->Dorea
p1<-ggplot(Dorea, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Dorea") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Dorea.pdf",p1,height = 3,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Intestinibacter"),]->Intestinibacter
p1<-ggplot(Intestinibacter, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Intestinibacter") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Intestinibacter.pdf",p1,height = 3,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Porphyromonas"),]->Porphyromonas
p1<-ggplot(Porphyromonas, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Porphyromonas") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Porphyromonas.pdf",p1,height = 3,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Providencia"),]->Providencia
p1<-ggplot(Providencia, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Providencia") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Providencia.pdf",p1,height = 3,width = 15,units = "cm")




table(sign_growth$taxon)
sign_growth[which(sign_growth$taxon=="Pseudomonas"),]->Pseudomonas
p1<-ggplot(Pseudomonas, aes(x = growth_rate, y = Sex, color = Group)) +
  geom_point() + # 使用点形态来展现
  theme_minimal() + # 使用简洁主题
  labs( x = "growth_rate", y = "Pseudomonas") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+  
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ 
  scale_x_continuous(limits = c(1e-04,0.005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
ggsave("Pseudomonas.pdf",p1,height = 3,width = 15,units = "cm")


```



```{r}
#####代谢通量
read.csv("exchange_fluxes.csv",header = TRUE)->exchange_fluxes
exchange_fluxes[,-4]->exchange_fluxes
unique(exchange_fluxes$metabolite)->metabolite
unique(exchange_fluxes$sample_id)->sample
flux<-matrix(exchange_fluxes$flux,length(metabolite),length(sample))
colnames(flux)<-sample
rownames(flux)<-metabolite
#write.csv(flux,"flux.csv")

read.csv("flux.csv",header = TRUE,row.names = 1)->flux
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
flux[,match(rownames(meta)[which(meta$Group=="ASD")],colnames(flux))]->ASD_flux
flux[,match(rownames(meta)[which(meta$Group=="Health")],colnames(flux))]->Health_flux
t(flux)->flux
t(ASD_flux)->ASD_flux
t(Health_flux)->Health_flux

p<-c()
for (i in 1:length(ASD_flux[1,])) {
  wilcox.test(ASD_flux[,i],Health_flux[,i])$p.val->p[i]
  #t.test(ASD[,i],Health[,i])$stat->q[i]
}
as.matrix(p)->p
rownames(p)<-colnames(ASD_flux)
rownames(p)[which(p<0.05)]->sign_all
c<-which(colnames(flux)=="met_L_m"|colnames(flux)=="cys_L_m"|colnames(flux)=="val_L_m"|colnames(flux)=="ala_D_m"|colnames(flux)=="glu_L_m")
flux[,c]->flux

read.csv("meta.csv")->meta
meta[match(rownames(flux),meta$X),]->meta
library(tidyverse)
flux->sign_flux
c(sign_flux[,1],sign_flux[,2])%>%as.matrix()->a
for (i in 3:ncol(sign_flux)) {
  c(a,sign_flux[,i])%>%as.matrix()->a
}

rep(meta$Group,ncol(sign_flux))->b
cbind(a,b)->a
colnames(sign_flux)->c
rep(c,each=length(sign))->c
cbind(c,a)->a
colnames(a)<-c("metabolic","flux","group")
flux<-a
#write.csv(a,"flux1.csv")
#read.csv("flux1.csv",header = TRUE)->flux
as.data.frame(flux)->flux
flux$flux<-as.numeric(flux$flux)
flux[-which(flux$flux==0.0001),]->flux
p<-ggplot(flux,aes(y=metabolic,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+ 
  scale_x_continuous(limits = c(1e-04,0.0005))+ggtitle("A")#标题

library(ggpubr)
p1 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
   scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+
  ggtitle('A')
ggsave("整体代谢通量差异箱线图.pdf",p1)

read.csv("flux.csv",header = TRUE,row.names = 1)->flux
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
flux[,match(rownames(meta)[which(meta$Sex=="Female")],colnames(flux))]->Female_flux
meta[match(colnames(Female_flux),rownames(meta)),]->Female_meta


Female_flux[,match(rownames(Female_meta)[which(Female_meta$Group=="ASD")],colnames(Female_flux))]->ASD_flux
Female_flux[,match(rownames(Female_meta)[which(Female_meta$Group=="Health")],colnames(Female_flux))]->Health_flux
t(Female_flux)->Female_flux
t(ASD_flux)->ASD_flux
t(Health_flux)->Health_flux               
p<-c()
for (i in 1:length(ASD_flux[1,])) {
  wilcox.test(ASD_flux[,i],Health_flux[,i])$p.val->p[i]
  #t.test(ASD[,i],Health[,i])$stat->q[i]
}
as.matrix(p)->p1
rownames(p1)<-colnames(ASD_flux)
rownames(p)[which(p<0.05)]->sign_Female
####最小的5个
c<-which(colnames(Female_flux)=="ile_L_m"|colnames(Female_flux)=="leu_L_m"|colnames(Female_flux)=="val_L_m"|colnames(Female_flux)=="acnam_m"|colnames(Female_flux)=="tyr_L_m")
Female_flux[,c]->Female_flux
sign_flux<-Female_flux

c(sign_flux[,1],sign_flux[,2])%>%as.matrix()->a
for (i in 3:ncol(sign_flux)) {
  c(a,sign_flux[,i])%>%as.matrix()->a
}
rep(Female_meta$Group,ncol(sign_flux))->b
cbind(a,b)->a
colnames(sign_flux)->c
rep(c,each=length(sign))->c
cbind(c,a)->a
colnames(a)<-c("metabolic","flux","group")
flux<-a
#write.csv(a,"flux1.csv")
#read.csv("flux1.csv",header = TRUE)->flux
as.data.frame(flux)->flux
flux$flux<-as.numeric(flux$flux)
flux[-which(flux$flux==0.0001),]->flux
p<-ggplot(flux,aes(y=metabolic,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+#图例位置
  ggtitle("C")+#标题
  scale_x_continuous(limits = c(1e-04,0.0005))


library(ggpubr)
p2 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))


#####男性

read.csv("flux.csv",header = TRUE,row.names = 1)->flux
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
flux[,match(rownames(meta)[which(meta$Sex=="Male")],colnames(flux))]->Male_flux
meta[match(colnames(Male_flux),rownames(meta)),]->Male_meta


Male_flux[,match(rownames(Male_meta)[which(Male_meta$Group=="ASD")],colnames(Male_flux))]->ASD_flux
Male_flux[,match(rownames(Male_meta)[which(Male_meta$Group=="Health")],colnames(Male_flux))]->Health_flux
t(Male_flux)->Male_flux
t(ASD_flux)->ASD_flux
t(Health_flux)->Health_flux               
p<-c()
for (i in 1:length(ASD_flux[1,])) {
  wilcox.test(ASD_flux[,i],Health_flux[,i])$p.val->p[i]
  #t.test(ASD[,i],Health[,i])$stat->q[i]
}
as.matrix(p)->p2
rownames(p2)<-colnames(ASD_flux)
rownames(p)[which(p<0.05)]->sign_Male
####最小的5个
c<-which(colnames(Male_flux)=="met_L_m"|colnames(Male_flux)=="15dap_m"|colnames(Male_flux)=="cys_L_m"|colnames(Male_flux)=="uri_m"|colnames(Male_flux)=="ala_D_m")
Male_flux[,c]->Male_flux
sign_flux<-Male_flux

c(sign_flux[,1],sign_flux[,2])%>%as.matrix()->a
for (i in 3:ncol(sign_flux)) {
  c(a,sign_flux[,i])%>%as.matrix()->a
}
rep(Male_meta$Group,ncol(sign_flux))->b
cbind(a,b)->a
colnames(sign_flux)->c
rep(c,each=length(sign))->c
cbind(c,a)->a
colnames(a)<-c("metabolic","flux","group")
flux<-a
#write.csv(a,"flux1.csv")
#read.csv("flux1.csv",header = TRUE)->flux
as.data.frame(flux)->flux
flux$flux<-as.numeric(flux$flux)
flux[-which(flux$flux==0.0001),]->flux

library(ggsignif)
p<-ggplot(flux,aes(y=metabolic,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+#图例位置+
   geom_signif(comparisons = list(c("ASD", "Health")), 
    map_signif_level = TRUE)+ scale_x_continuous(limits = c(1e-04,0.0005))


library(ggpubr)
p3 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = F, #是否使用*显示
                     test = wilcox.test, ##计算方法
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ggtitle('B')
  
p3











rownames(p2)[na.omit(match(rownames(p1)[which(p1<0.05)],rownames(p2)[which(p2<0.05)]))]->a

Male_flux[,match(a,colnames(Male_flux))]->Male_flux
sign_flux<-Male_flux

c(sign_flux[,1],sign_flux[,2])%>%as.matrix()->a
for (i in 3:ncol(sign_flux)) {
  c(a,sign_flux[,i])%>%as.matrix()->a
}
rep(Male_meta$Group,ncol(sign_flux))->b
cbind(a,b)->a
colnames(sign_flux)->c
rep(c,each=length(sign))->c
cbind(c,a)->a
colnames(a)<-c("metabolic","flux","group")
flux<-a
#write.csv(a,"flux1.csv")
read.csv("flux1.csv",header = TRUE)->flux
as.data.frame(flux)->flux
flux$flux<-as.numeric(flux$flux)
flux[-which(flux$flux==0.0001),]->flux

library(ggsignif)
p<-ggplot(flux,aes(y=metabolic,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+#图例位置+
   geom_signif(comparisons = list(c("ASD", "Health")), 
    map_signif_level = TRUE)+ scale_x_continuous(limits = c(1e-04,0.0005))


library(ggpubr)
p3 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = F, #是否使用*显示
                     test = wilcox.test, ##计算方法
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))+ggtitle('B')
  
p3
cbind(flux,rep("Male",length(flux[,1])))->Male_flux_group
colnames(Male_flux_group)[ncol(Male_flux_group)]<-"Group"

t(Female_flux)->Female_flux
rownames(p2)[na.omit(match(rownames(p1)[which(p1<0.05)],rownames(p2)[which(p2<0.05)]))]->a
Female_flux[,match(a,colnames(Female_flux))]->Female_flux
sign_flux<-Female_flux

c(sign_flux[,1],sign_flux[,2])%>%as.matrix()->a
for (i in 3:ncol(sign_flux)) {
  c(a,sign_flux[,i])%>%as.matrix()->a
}
rep(Female_meta$Group,ncol(sign_flux))->b
cbind(a,b)->a
colnames(sign_flux)->c
rep(c,each=length(sign))->c
cbind(c,a)->a
colnames(a)<-c("metabolic","flux","group")
flux<-a
#write.csv(a,"flux1.csv")
#read.csv("flux1.csv",header = TRUE)->flux
as.data.frame(flux)->flux
flux$flux<-as.numeric(flux$flux)
flux[-which(flux$flux==0.0001),]->flux
p<-ggplot(flux,aes(y=metabolic,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+#图例位置
  ggtitle("C")+#标题
  scale_x_continuous(limits = c(1e-04,0.0005))


library(ggpubr)
p2 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
cbind(flux,rep("Female",length(flux[,1])))->Female_flux_group
colnames(Female_flux_group)[ncol(Female_flux_group)]<-"Group"
rbind(Male_flux_group,Female_flux_group)->All
colnames(All)[ncol(All)]<-"Class"




rbind(Male_flux,Female_flux)->uri_m
sign_flux<-uri_m

c(sign_flux[,1],sign_flux[,2])%>%as.matrix()->a
for (i in 3:ncol(sign_flux)) {
  c(a,sign_flux[,i])%>%as.matrix()->a
}
#c(Male_meta$Group,Female_meta$Group)


rep(c(Male_meta$Group,Female_meta$Group),ncol(sign_flux))->b
cbind(a,b)->a
colnames(sign_flux)->c
rep(c,each=length(sign))->c
cbind(c,a)->a
colnames(a)<-c("metabolic","flux","group")
flux<-a
#write.csv(a,"flux1.csv")
#read.csv("flux1.csv",header = TRUE)->flux
as.data.frame(flux)->flux
flux$flux<-as.numeric(flux$flux)
rep(c(Male_meta$Sex,Female_meta$Sex),ncol(sign_flux))->d
cbind(flux,d)->flux
flux[-which(flux$flux==0.0001),]->flux
table(flux$metabolic)
######uri_m
colnames(flux)[ncol(flux)]<-"Sex"



flux$group[which(flux$group=="AHealth")]<-"Health"
```



```{r}
uri_m$metabolic[which(uri_m$metabolic=="uri_m")]<-"Uridine"
p<-ggplot(uri_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("Uridine1.pdf",p,height = 7,width = 30,units = "cm")

gam_m$metabolic[which(gam_m$metabolic=="gam_m")]<-"D-Glucosamine"
p<-ggplot(gam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("D-Glucosamine1.pdf",p,height = 7,width = 30,units = "cm")




acnam_m$metabolic[which(acnam_m$metabolic=="acnam_m")]<-"N-acetylneuraminate"
p<-ggplot(acnam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("N-acetylneuraminate1.pdf",p,height = 7,width = 30,units = "cm")



cys_L_m$metabolic[which(cys_L_m$metabolic=="cys_L_m")]<-"L-cysteine"
p<-ggplot(cys_L_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("L-cysteine1.pdf",p,height = 7,width = 30,units = "cm")


acgam_m$metabolic[which(acgam_m$metabolic=="acgam_m")]<-"N-acetyl-D-glucosamine"
p<-ggplot(acgam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("N-acetyl-D-glucosamine1.pdf",p,height = 7,width = 30,units = "cm")




adn_m$metabolic[which(adn_m$metabolic=="adn_m")]<-"Adenosine"
p<-ggplot(adn_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("Adenosine1.pdf",p,height = 7,width = 30,units = "cm")



dad_2_m$metabolic[which(dad_2_m$metabolic=="dad_2_m")]<-"2-deoxyadenosine"
p<-ggplot(dad_2_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("2-deoxyadenosine1.pdf",p,height = 7,width = 30,units = "cm")



dgsn_m$metabolic[which(dgsn_m$metabolic=="dgsn_m")]<-"Deoxyguanosine"
p<-ggplot(dgsn_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("Deoxyguanosine1.pdf",p,height = 7,width = 30,units = "cm")



phe_L_m$metabolic[which(phe_L_m$metabolic=="phe_L_m")]<-"L-phenylalanine"
p<-ggplot(phe_L_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("L-phenylalanine1.pdf",p,height = 7,width = 30,units = "cm")



g6p_m$metabolic[which(g6p_m$metabolic=="g6p_m")]<-"D-Glucose—6-phosphate"
p<-ggplot(g6p_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("D-Glucose—6-phosphate1.pdf",p,height = 7,width = 30,units = "cm")



ncam_m$metabolic[which(ncam_m$metabolic=="ncam_m")]<-"Nicotinamide"
p<-ggplot(ncam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("Nicotinamide1.pdf",p,height = 7,width = 30,units = "cm")



amet_m$metabolic[which(amet_m$metabolic=="amet_m")]<-"S-Adenosyl-L-methionine"
p<-ggplot(amet_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("S-Adenosyl-L-methionine1.pdf",p,height = 7,width = 30,units = "cm")





duri_m$metabolic[which(duri_m$metabolic=="duri_m")]<-"Deoxyuridine"
p<-ggplot(duri_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+
  scale_x_continuous(limits = c(1e-04,0.0005))
p<-p + 
  facet_wrap(~metabolic, strip.position = "left") + 
  theme_half_open(12) + 
  background_grid() + 
  theme(
    strip.background = element_blank(), 
    strip.placement = "outside",  # Move strips outside of the plotting area
    strip.text.y.left = element_textbox(
      size = 12, 
      color = "white", 
      fill = "#5D729D", 
      box.color = "#4A618C", 
      halign = 0.5, 
      linetype = 1, 
      r = unit(5, "pt"), 
      width = unit(1, "npc"), 
      padding = margin(2, 0, 1, 0), 
      margin = margin(3, 3, 3, 3),
      orientation = "left-rotated"
    )
  )
ggsave("Deoxyuridine1.pdf",p,height = 7,width = 30,units = "cm")
```






```{r}
library(tidyverse)
library(palmerpenguins)
background <- function() {
  grobTree(
    rectGrob(y = 0.75, x = 0.5, width = 1, height = 0.5, gp = gpar(fill = "yellow", alpha = 0.2)),
    rectGrob(y = 0.25, x = 0.5, width = 1, height = 0.5, gp = gpar(fill = "green", alpha = 0.2))
  )
}

flux[which(flux$metabolic=="uri_m"),]->uri_m 

p<-ggplot(uri_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14),
        strip.background = element_blank(),
         strip.text = element_textbox(
             size = 12,
             color = "white", fill = "#5D729D", box.color = "#4A618C",
             halign = 0.5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
             padding = margin(2, 0, 1, 0), margin = margin(3, 3, 3, 3)))+#图例位置
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)

#desired_order <- c('Male','Female')
library(ggpubr)
p2 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     x_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("Uridine.pdf",p2,height = 7,width = 30,units = "cm")

flux[which(flux$metabolic=="gam_m"),]->gam_m 
p<-ggplot(gam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
library(ggpubr)
p3 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     x_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("D-Glucosamine.pdf",p3,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="acnam_m"),]->acnam_m 
p<-ggplot(acnam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


#desired_order <- c('Male','Female')
library(ggpubr)
p4 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     x_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("N-acetylneuraminate.pdf",p4,height = 7,width = 30,units = "cm")



flux[which(flux$metabolic=="cys_L_m"),]->cys_L_m 
p<-ggplot(cys_L_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p6 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     x_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("L-cysteine.pdf",p6,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="acgam_m"),]->acgam_m 
p<-ggplot(acgam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p5 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("N-acetyl-D-glucosamine.pdf",p5,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="adn_m"),]->adn_m 
p<-ggplot(adn_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p7 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("Adenosine.pdf",p7,height = 7,width = 30,units = "cm")



colnames(Male_flux)

flux[which(flux$metabolic=="dad_2_m"),]->dad_2_m 
p<-ggplot(dad_2_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p8 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("2-deoxyadenosine.pdf",p8,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="dgsn_m"),]->dgsn_m 
p<-ggplot(dgsn_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)

library(ggpubr)
p9 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("Deoxyguanosine.pdf",p9,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="phe_L_m"),]->phe_L_m 
p<-ggplot(phe_L_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)

library(ggpubr)
p10 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("L-phenylalanine.pdf",p10,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="g6p_m"),]->g6p_m 
p<-ggplot(g6p_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p11 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("D-Glucose—6-phosphate.pdf",p11,height = 7,width = 30,units = "cm")


flux[which(flux$metabolic=="ncam_m"),]->ncam_m 
p<-ggplot(ncam_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p12 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("Nicotinamide.pdf",p12,height = 7,width = 30,units = "cm")






colnames(Male_flux)
flux[which(flux$metabolic=="amet_m"),]->amet_m 
p<-ggplot(amet_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)

library(ggpubr)
p13 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('ASD' = "#EB7369",'Health' = '#5784C4'))
ggsave("S-Adenosyl-L-methionine.pdf",p13,height = 7,width = 30,units = "cm")





colnames(Male_flux)
flux[which(flux$metabolic=="duri_m"),]->duri_m 
p<-ggplot(duri_m,aes(y=Sex,x=flux))+#指定数据
  stat_boxplot(geom = "errorbar", width=0.1,size=0.8)+#添加误差线,注意位置，放到最后则这条先不会被箱体覆盖
  geom_boxplot(aes(fill=group), #绘制箱线图函数
               outlier.colour="white",size=0.8)+#异常点去除
  theme(panel.background =element_blank(), #背景
        axis.line=element_line(),#坐标轴的线设为显示
        legend.position="none",plot.title = element_text(size=14))+
  scale_x_continuous(limits = c(1e-04,0.0005))+
  annotation_custom(background(), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)


library(ggpubr)
p14 <- p + geom_signif(comparisons = list(c("Health","ASD")),# 设置需要比较的组
                     map_signif_level = T, #是否使用*显示
                     test = t.test, ##计算方法
                     y_position = c(23,30,26),#图中横线位置设置
                     tip_length = c(c(0.05,0.05),
                                    c(0.05,0.05),
                                    c(0.05,0.05)),#横线下方的竖线设置
                     size=0.8,color="black")+
  scale_fill_manual(values = c('Health' = '#5784C4','ASD' = "#EB7369"))
ggsave("Deoxyuridine.pdf",p14,height = 7,width = 30,units = "cm")


```
match(colnames)

```{r}
#####模型构建


####物种

####整体
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



####男性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')


####女性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')
```

```{r}
####代谢通量

####整体
read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



####男性
read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
colnames(otu)[ncol(otu)]<-"type"
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')


####女性
read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')
```
```{r}
####物种+代谢通量

####整体
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("flux.csv",row.names = 1,header = TRUE)->otu1
t(otu1)->otu1
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,otu1,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



####男性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu)),]->otu
read.csv("flux.csv",row.names = 1,header = TRUE)->otu1
t(otu1)->otu1
otu1[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu1)),]->otu1
otu<-cbind(otu,otu1,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
colnames(otu)[ncol(otu)]<-"type"
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')


####女性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu)),]->otu
read.csv("flux.csv",row.names = 1,header = TRUE)->otu1
t(otu1)->otu1
otu1[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu1)),]->otu1
otu<-cbind(otu,otu1,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')
```



```{r}
####显著物种+显著代谢通量

####整体
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("flux.csv",row.names = 1,header = TRUE)->otu1
t(otu1)->otu1
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,otu1,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
which(colnames(otu)=='Collinsella'|colnames(otu)=="Pseudonocardia"|colnames(otu)=="Corynebacterium"|colnames(otu)=="Clavibacter"|colnames(otu)=="Pediococcus"|colnames(otu)=="Enterococcus"|colnames(otu)=="Staphylococcus"|colnames(otu)=="Bacillus"|colnames(otu)=="Clostridium"|colnames(otu)=="Eubacterium"|colnames(otu)=="Ruminococcus"|colnames(otu)=="Subdoligranulum"|colnames(otu)=="Coprococcus"|colnames(otu)=="Dorea"|colnames(otu)=="Roseburia"|colnames(otu)=="Brevundimonas"|colnames(otu)=="Neisseria"|colnames(otu)=="Sutterella"|colnames(otu)=="Photobacterium"|colnames(otu)=="Aeromonas"|colnames(otu)=="Succinivibrio"|colnames(otu)=="Pseudomonas"|colnames(otu)=="Acinetobacter"|colnames(otu)=="Moraxella"|colnames(otu)=="Cronobacter"|colnames(otu)=="Citrobacter"|colnames(otu)=="Arsenophonus"|colnames(otu)=="Proteus"|colnames(otu)=="Providencia"|colnames(otu)=="Salmonella"|colnames(otu)=="Yersinia"|colnames(otu)=="Methanobrevibacter"|colnames(otu)=="Caldilinea"|colnames(otu)=="Leptotrichia"|colnames(otu)=="Truepera"|colnames(otu)=="Ureaplasma"|colnames(otu)=="Barnesiella"|colnames(otu)=="Paludibacter"|colnames(otu)=="Porphyromonas"|colnames(otu)=="Sphingobacterium")->a
match(sign_all,colnames(otu))->c
otu[,c(a,c,ncol(otu))]->otu

library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



####男性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu)),]->otu
read.csv("flux.csv",row.names = 1,header = TRUE)->otu1
t(otu1)->otu1
otu1[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu1)),]->otu1
otu<-cbind(otu,otu1,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
which(colnames(otu)=='Collinsella'|colnames(otu)=="Sphingobacterium"|colnames(otu)=="Porphyromonas"|colnames(otu)=="Butyricimonas"|colnames(otu)=="Prevotella"|colnames(otu)=="Methanobrevibacter"|colnames(otu)=="Rahnella"|colnames(otu)=="Acinetobacter"|colnames(otu)=="Pseudomonas"|colnames(otu)=="Neisseria"|colnames(otu)=="Subdoligranulum"|colnames(otu)=="Bacillus"|colnames(otu)=="Staphylococcus"|colnames(otu)=="Enterococcus"|colnames(otu)=="Pediococcus"|colnames(otu)=="Clavibacter")->c
match(sign_Male,colnames(otu))->a
otu[,c(a,c,ncol(otu))]->otu
library(lattice)
library(caret)
as.data.frame(otu)->otu
colnames(otu)[ncol(otu)]<-"type"
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')


####女性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu)),]->otu
read.csv("flux.csv",row.names = 1,header = TRUE)->otu1
t(otu1)->otu1
otu1[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu1)),]->otu1
otu<-cbind(otu,otu1,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
which(colnames(otu)=='Truepera'|colnames(otu)=="Salmonella"|colnames(otu)=="Providencia"|colnames(otu)=="Acinetobacter"|colnames(otu)=="Pseudomonas"|colnames(otu)=="Coprococcus"|colnames(otu)=="Bacillus"|colnames(otu)=="Staphylococcus")->c
match(sign_Female,colnames(otu))->a
otu[,c(a,c,ncol(otu))]->otu
library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')
```







```{r}
#####模型构建


####显著物种

####整体
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
which(colnames(otu)=='Collinsella'|colnames(otu)=="Pseudonocardia"|colnames(otu)=="Corynebacterium"|colnames(otu)=="Clavibacter"|colnames(otu)=="Pediococcus"|colnames(otu)=="Enterococcus"|colnames(otu)=="Staphylococcus"|colnames(otu)=="Bacillus"|colnames(otu)=="Clostridium"|colnames(otu)=="Eubacterium"|colnames(otu)=="Ruminococcus"|colnames(otu)=="Subdoligranulum"|colnames(otu)=="Coprococcus"|colnames(otu)=="Dorea"|colnames(otu)=="Roseburia"|colnames(otu)=="Brevundimonas"|colnames(otu)=="Neisseria"|colnames(otu)=="Sutterella"|colnames(otu)=="Photobacterium"|colnames(otu)=="Aeromonas"|colnames(otu)=="Succinivibrio"|colnames(otu)=="Pseudomonas"|colnames(otu)=="Acinetobacter"|colnames(otu)=="Moraxella"|colnames(otu)=="Cronobacter"|colnames(otu)=="Citrobacter"|colnames(otu)=="Arsenophonus"|colnames(otu)=="Proteus"|colnames(otu)=="Providencia"|colnames(otu)=="Salmonella"|colnames(otu)=="Yersinia"|colnames(otu)=="Methanobrevibacter"|colnames(otu)=="Caldilinea"|colnames(otu)=="Leptotrichia"|colnames(otu)=="Truepera"|colnames(otu)=="Ureaplasma"|colnames(otu)=="Barnesiella"|colnames(otu)=="Paludibacter"|colnames(otu)=="Porphyromonas"|colnames(otu)=="Sphingobacterium")->c
otu[,c(c,ncol(otu))]->otu

library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



####男性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
which(colnames(otu)=='Collinsella'|colnames(otu)=="Sphingobacterium"|colnames(otu)=="Porphyromonas"|colnames(otu)=="Butyricimonas"|colnames(otu)=="Prevotella"|colnames(otu)=="Methanobrevibacter"|colnames(otu)=="Rahnella"|colnames(otu)=="Acinetobacter"|colnames(otu)=="Pseudomonas"|colnames(otu)=="Neisseria"|colnames(otu)=="Subdoligranulum"|colnames(otu)=="Bacillus"|colnames(otu)=="Staphylococcus"|colnames(otu)=="Enterococcus"|colnames(otu)=="Pediococcus"|colnames(otu)=="Clavibacter")->c
otu[,c(c,ncol(otu))]->otu


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')


####女性
read.csv("dlkcsa.csv")->otu
otu<-otu[which(otu[,1]!=''),]
rownames(otu)<-otu[,1]
otu<-otu[,-1]
otu[is.na(otu)]=0
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
which(colnames(otu)=='Truepera'|colnames(otu)=="Salmonella"|colnames(otu)=="Providencia"|colnames(otu)=="Acinetobacter"|colnames(otu)=="Pseudomonas"|colnames(otu)=="Coprococcus"|colnames(otu)=="Bacillus"|colnames(otu)=="Staphylococcus")->c
otu[,c(c,ncol(otu))]->otu


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')
```



```{r}
####显著代谢通量





####整体
read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
match(sign_all,colnames(otu))->c
otu[,c(c,ncol(otu))]->otu

library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



####男性
read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Male")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
match(sign_Male,colnames(otu))->c
otu[,c(c,ncol(otu))]->otu

library(lattice)
library(caret)
as.data.frame(otu)->otu
colnames(otu)[ncol(otu)]<-"type"
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')


####女性
read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu[match(rownames(meta)[which(meta$Sex=="Female")],rownames(otu)),]->otu
otu<-cbind(otu,meta$Group[match(rownames(otu),rownames(meta))])
colnames(otu)[ncol(otu)]<-"type"
match(sign_Female,colnames(otu))->c
otu[,c(c,ncol(otu))]->otu

library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')
```


```{r}
#####代谢通量降维图
library(ggplot2)
setwd("D:\\360安全浏览器下载\\课题\\6月份\\根据菌群距离选择健康样本\\整体micom")
read.csv("整体降维.csv")->tsen
read.csv("meta.csv",row.names = 1)->meta
rownames(meta)[which(meta$Sex=="Male"&meta$Group=="Health")]->MH
which(tsen$sample_id==MH)


cbind(tsen,meta$Sex[match(tsen$sample_id,rownames(meta))],meta$Group[match(tsen$sample_id,rownames(meta))])->tsen
colnames(tsen)[5:6]<-c("Sex","Group")





read.csv("manifest1.csv",row.names = 1)->manifest
#####order
manifest$order[match(tsen$taxon,manifest$genus)]->tsen$taxon
na.omit(tsen)->tsen
tsen[which(tsen$Sex=="Male"&tsen$Group=="Health"),]->tsne_out1
tsen[which(tsen$Sex=="Male"&tsen$Group=="ASD"),]->tsne_out2
tsen[which(tsen$Sex=="Female"&tsen$Group=="Health"),]->tsne_out3
tsen[which(tsen$Sex=="Female"&tsen$Group=="ASD"),]->tsne_out4
c(tsne_out1$taxon,tsne_out2$taxon,tsne_out3$taxon,tsne_out4$taxon)->genus
unique(genus)->genus
set.seed(123)  # 为了结果可复现，我们设置一个种子
color_vector <- rgb(runif(length(genus)), runif(length(genus)), runif(length(genus)))  # 这将生成171个颜色的向量
cbind(genus,color_vector)->genus
as.data.frame(genus)->genus
genus[match(tsne_out1$taxon,genus$genus),]->genus1
colors1 <- setNames(genus1$color_vector,genus1$genus)

genus[match(tsne_out2$taxon,genus$genus),]->genus2
colors2 <- setNames(genus2$color_vector,genus2$genus)


genus[match(tsne_out3$taxon,genus$genus),]->genus3
colors3 <- setNames(genus3$color_vector,genus3$genus)

genus[match(tsne_out4$taxon,genus$genus),]->genus4
colors4 <- setNames(genus4$color_vector,genus4$genus)


tsne_result = as.data.frame(tsne_out1[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p1<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out1$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors1)+ theme(legend.position = "none")+ggtitle('A')


tsne_result = as.data.frame(tsne_out2[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p2<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out2$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors2)+ theme(legend.position = "none")+ggtitle('B')


tsne_result = as.data.frame(tsne_out3[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p3<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out3$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors3)+ theme(legend.position = "none")+ggtitle('C')


tsne_result = as.data.frame(tsne_out4[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p4<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out4$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors4)+ggtitle('D')

library(gridExtra)
p1+p2+p3+p4->p
ggsave("tsen.pdf",p,height=90,width=90,unit="cm",limitsize = FALSE)




#####class
read.csv("整体降维.csv")->tsen
read.csv("meta.csv",row.names = 1)->meta
rownames(meta)[which(meta$Sex=="Male"&meta$Group=="Health")]->MH
which(tsen$sample_id==MH)


cbind(tsen,meta$Sex[match(tsen$sample_id,rownames(meta))],meta$Group[match(tsen$sample_id,rownames(meta))])->tsen
colnames(tsen)[5:6]<-c("Sex","Group")
manifest$class[match(tsen$taxon,manifest$genus)]->tsen$taxon
na.omit(tsen)->tsen
tsen[which(tsen$Sex=="Male"&tsen$Group=="Health"),]->tsne_out1
tsen[which(tsen$Sex=="Male"&tsen$Group=="ASD"),]->tsne_out2
tsen[which(tsen$Sex=="Female"&tsen$Group=="Health"),]->tsne_out3
tsen[which(tsen$Sex=="Female"&tsen$Group=="ASD"),]->tsne_out4
c(tsne_out1$taxon,tsne_out2$taxon,tsne_out3$taxon,tsne_out4$taxon)->genus
unique(genus)->genus
set.seed(123)  # 为了结果可复现，我们设置一个种子
color_vector <- rgb(runif(length(genus)), runif(length(genus)), runif(length(genus)))  # 这将生成171个颜色的向量
cbind(genus,color_vector)->genus
as.data.frame(genus)->genus
genus[match(tsne_out1$taxon,genus$genus),]->genus1
colors1 <- setNames(genus1$color_vector,genus1$genus)

genus[match(tsne_out2$taxon,genus$genus),]->genus2
colors2 <- setNames(genus2$color_vector,genus2$genus)


genus[match(tsne_out3$taxon,genus$genus),]->genus3
colors3 <- setNames(genus3$color_vector,genus3$genus)

genus[match(tsne_out4$taxon,genus$genus),]->genus4
colors4 <- setNames(genus4$color_vector,genus4$genus)


tsne_result = as.data.frame(tsne_out1[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p1<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out1$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors1)+ theme(legend.position = "none")+ggtitle('A')


tsne_result = as.data.frame(tsne_out2[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p2<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out2$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors2)+ theme(legend.position = "none")+ggtitle('B')


tsne_result = as.data.frame(tsne_out3[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p3<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out3$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors3)+ theme(legend.position = "none")+ggtitle('C')


tsne_result = as.data.frame(tsne_out4[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p4<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out4$taxon,genus$genus)]
)) +
geom_point()+scale_color_manual(values = colors4)+ggtitle('D')
















#####phylum
read.csv("整体降维.csv")->tsen
read.csv("meta.csv",row.names = 1)->meta
#rownames(meta)[which(meta$Sex=="Male"&meta$Group=="Health")]->MH
#which(tsen$sample_id==MH)


cbind(tsen,meta$Sex[match(tsen$sample_id,rownames(meta))],meta$Group[match(tsen$sample_id,rownames(meta))])->tsen
colnames(tsen)[5:6]<-c("Sex","Group")
manifest$phylum[match(tsen$taxon,manifest$genus)]->tsen$taxon
na.omit(tsen)->tsen
tsen[which(tsen$Sex=="Male"&tsen$Group=="Health"),]->tsne_out1
tsen[which(tsen$Sex=="Male"&tsen$Group=="ASD"),]->tsne_out2
tsen[which(tsen$Sex=="Female"&tsen$Group=="Health"),]->tsne_out3
tsen[which(tsen$Sex=="Female"&tsen$Group=="ASD"),]->tsne_out4
c(tsne_out1$taxon,tsne_out2$taxon,tsne_out3$taxon,tsne_out4$taxon)->genus
unique(genus)->genus
set.seed(123)  # 为了结果可复现，我们设置一个种子
color_vector <- rgb(runif(length(genus)), runif(length(genus)), runif(length(genus)))  # 这将生成171个颜色的向量
cbind(genus,color_vector)->genus
as.data.frame(genus)->genus
genus$color_vector[which(genus$genus=="Bacteroidetes")]<-"#1E77B4"
genus$color_vector[which(genus$genus=="Firmicutes")]<-"#FF800E"
genus$color_vector[which(genus$genus=="Proteobacteria")]<-"#2C9F2C"
genus$color_vector[which(genus$genus=="Actinobacteria")]<-"#D72729"
genus$color_vector[which(genus$genus=="Verrucomicrobia")]<-"#9468BE"
genus$color_vector[which(genus$genus=="Euryarchaeota")]<-"#8B564A"
genus$color_vector[which(genus$genus=="Fusobacteria")]<-"#E376C1"
genus$color_vector[which(genus$genus=="Synergistetes")]<-"#7F7F7F"
genus$color_vector[which(genus$genus=="Tenericutes")]<-"#BCBC22"
genus$color_vector[which(genus$genus=="Spirochaetes")]<-"#16BED0"

genus[match(tsne_out1$taxon,genus$genus),]->genus1
colors1 <- setNames(genus1$color_vector,genus1$genus)

genus[match(tsne_out2$taxon,genus$genus),]->genus2
colors2 <- setNames(genus2$color_vector,genus2$genus)


genus[match(tsne_out3$taxon,genus$genus),]->genus3
colors3 <- setNames(genus3$color_vector,genus3$genus)

genus[match(tsne_out4$taxon,genus$genus),]->genus4
colors4 <- setNames(genus4$color_vector,genus4$genus)


tsne_result = as.data.frame(tsne_out1[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p1<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out1$taxon,genus$genus)]
)) +geom_point()+scale_color_manual(values = colors1)+ggtitle('Male_Health')+theme_bw()+
theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
p1<-p1+ theme(legend.position = "none")

tsne_result = as.data.frame(tsne_out2[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p2<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out2$taxon,genus$genus)]
)) +geom_point()+scale_color_manual(values = colors2)+ggtitle('Male_ASD')+theme_bw()+
theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
p2<-p2+ theme(legend.position = "none")

tsne_result = as.data.frame(tsne_out3[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p3<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out3$taxon,genus$genus)]
)) +geom_point()+scale_color_manual(values = colors3)+ggtitle('Female_Health')+theme_bw()+
theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
p3<-p3+ theme(legend.position = "none")

tsne_result = as.data.frame(tsne_out4[,3:4])
colnames(tsne_result) = c("tSNE1","tSNE2")
p4<-ggplot(tsne_result,aes(tSNE1,tSNE2,color=genus$genus[match(tsne_out4$taxon,genus$genus)]
)) +geom_point()+scale_color_manual(values = colors4)+ggtitle('Female_ASD')+theme_bw()+
theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
p4<-p4+ theme(legend.position = "none")
p1+p2+p3+p4

```



```{r}
read.csv("yanzheng_genus.csv",row.names = 1,header = TRUE)->prove
cbind(colnames(prove),c(rep("ASD",143),rep("Health",(ncol(prove)-143))))%>%as.data.frame()->prove_meta
colnames(prove_meta)<-c("Sample","Group")
rownames(prove_meta)<-prove_meta$Sample
#####验证集
####新的数据集
read.csv("prove_flux.csv",header=TRUE)->prove_flux
prove_flux[,-4]->prove_flux
unique(prove_flux$metabolite)->metabolite
unique(prove_flux$sample_id)->sample
flux<-matrix(prove_flux$flux,length(metabolite),length(sample))
colnames(flux)<-sample
rownames(flux)<-metabolite

otu<-flux


####整体
#read.csv("flux.csv",row.names = 1,header = TRUE)->otu
t(otu)->otu
#read.csv("meta.csv",row.names = 1,header = TRUE)->meta
otu<-cbind(otu,prove_meta$Group[match(rownames(otu),rownames(prove_meta))])
colnames(otu)[ncol(otu)]<-"type"


library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')



otu<-flux
t(otu)->otu
otu<-cbind(otu,prove_meta$Group[match(rownames(otu),rownames(prove_meta))])
colnames(otu)[ncol(otu)]<-"type"
match(sign_all,colnames(otu))->c
na.omit(c)->c
c
otu[,c(c,ncol(otu))]->otu
#otu[,-92]->otu

library(lattice)
library(caret)
as.data.frame(otu)->otu
inTrain <- createDataPartition(y = otu$type, p =0.8, list = FALSE)
otu_train <- otu[-inTrain,]
otu_test <- otu[inTrain,]
train_index <- createFolds(otu_train$type, k = 10)
otu_train[,1:(ncol(otu)-1)] <- apply(otu_train[,1:(ncol(otu)-1)],2, as.numeric)
otu_train$type <- as.factor(otu_train$type)
otu_test[,1:(ncol(otu)-1)] <- apply(otu_test[,1:(ncol(otu)-1)],2, as.numeric)
otu_test$type <- as.factor(otu_test$type)
library("pROC")

#K-Nearest Neighbors
knnFit <- otu_train %>% train(type ~ .,
 method = "knn",
 data = .,
 preProcess = "scale",
 tuneLength = 5,
 tuneGrid=data.frame(k = 1:10),
 trControl = trainControl(method = "cv", indexOut = train_index))
knnFit
knnFit$finalModel
#KNN模型
rf.test<-predict(knnFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='k-近邻模型ROC曲线,mtry=3,ntree=1000')


#ctree
#install.packages("party")
ctreeFit <- otu_train %>% train(type ~ .,
 method = "ctree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
ctreeFit
plot(ctreeFit$finalModel)
#ctree模型 
rf.test<-predict(ctreeFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Conditional Inference Tree模型ROC曲线,mtry=3,ntree=1000')





#Linear Support Vector Machines
svmFit <- otu_train %>% train(type ~.,
 method = "svmLinear",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
svmFit
svmFit$finalModel
rf.test<-predict(svmFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='Linear Support Vector Machines模型ROC曲线,mtry=3,ntree=1000')



#Random Forest
randomForestFit <- otu_train %>% train(type ~ .,
 method = "rf",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index))
randomForestFit
randomForestFit$finalModel
#随机森林ROC曲线
rf.test<-predict(randomForestFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
p1<-plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"),
     max.auc.polygon=TRUE,auc.polygon.col="skyblue", 
     print.thres=TRUE,main='随机森林模型ROC曲线,mtry=3,ntree=1000')






#Gradient Boosted Decision Trees (xgboost)
 #install.packages("xgboost")
xgboostFit <- otu_train %>% train(type ~ .,
 method = "xgbTree",
 data = .,
 tuneLength = 5,
 trControl = trainControl(method = "cv", indexOut = train_index),
 tuneGrid = expand.grid(
 nrounds = 20,
 max_depth = 3,
 colsample_bytree = .6,
 eta = 0.1,
 gamma=0,
 min_child_weight = 1,
 subsample = .5
 ))
xgboostFit
xgboostFit$finalModel
rf.test<-predict(xgboostFit,newdata = otu_test,type = "raw")
rf.test
rf.cf<-caret::confusionMatrix(as.factor(rf.test),as.factor(otu_test$type))
rf.cf
ran_roc <- roc(as.factor(otu_test$type),as.numeric(rf.test),plot = T)
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), 
     max.auc.polygon=TRUE,auc.polygon.col="skyblue",
     print.thres=TRUE,main='Gradient Boosted Decision Trees模型ROC曲线,mtry=3,ntree=1000')

```